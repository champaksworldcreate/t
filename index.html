<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Programming Whiteboard PRO â€” Drag â€¢ Resize â€¢ Rotate â€¢ Draw â€¢ Connect â€¢ Save/Export</title>

<style>
:root{
  --bg:#fff7e6;--card:#fff;--ink:#1f2937;--muted:#6b7280;
  --brand:#d97706;--brand2:#f59e0b;
  --border:#eadcc5;--shadow:0 18px 40px rgba(31,41,55,.14);
  --grid:rgba(255,255,255,.08);
  --snap:rgba(245,158,11,.95);
  --safe:rgba(255,255,255,.18);
  --codebg:#0b1220;--codeink:#e5e7eb;
  --note:#fff6cc;
  --boardbg:#0a0a0a;
  --danger:#b91c1c;
  --ok:#166534;
}
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
.wrap{max-width:1600px;margin:18px auto;padding:14px}
h1{margin:0 0 10px;text-align:center;color:var(--brand);letter-spacing:.2px}
.grid{display:grid;grid-template-columns:420px 1fr;gap:14px;align-items:start}
.card{background:#fff;border:1px solid var(--border);border-radius:18px;box-shadow:var(--shadow);padding:14px}
small{color:var(--muted)}
hr{border:0;border-top:1px dashed var(--border);margin:12px 0}

button,input,select,textarea{font-family:inherit}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.row.tight{gap:6px}
.stack{display:grid;gap:10px}
kbd{font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#111827;color:#fff;padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.12)}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#fff}
.badge{display:inline-flex;align-items:center;gap:6px;padding:5px 8px;border-radius:999px;background:#fff;border:1px solid var(--border);color:var(--muted);font-weight:800}

/* Buttons */
.iconBtn{
  padding:8px 10px;border-radius:10px;border:1px solid rgba(0,0,0,.10);
  background:#fff;color:var(--ink);cursor:pointer;font-weight:900;box-shadow:0 8px 18px rgba(0,0,0,.06)
}
.iconBtn:hover{transform:translateY(-1px)}
.btn{padding:10px 12px;border-radius:12px;border:0;cursor:pointer;font-weight:900}
.btn.primary{background:linear-gradient(135deg,var(--brand),var(--brand2));color:#fff}
.btn.secondary{background:#fff;border:1px solid var(--brand);color:var(--brand)}
.btn.danger{background:var(--danger);color:#fff}
.btn:active,.iconBtn:active{transform:translateY(0)}
.sep{flex:1}

/* BOARD */
.boardWrap{position:relative}
#boardShell{
  position:relative;
  width:100%;
  aspect-ratio:16/9;
  border-radius:18px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.06);
  background:var(--boardbg);
}
#board{
  position:absolute; inset:0;
  background:var(--boardbg);
}
#board.gridOn{
  background-image:
    linear-gradient(to right,var(--grid) 1px,transparent 1px),
    linear-gradient(to bottom,var(--grid) 1px,transparent 1px);
  background-size:30px 30px;
}

/* SVG Links */
#linksSvg{position:absolute;inset:0;pointer-events:none}
.link{stroke:rgba(245,158,11,.95);stroke-width:3;fill:none;filter:drop-shadow(0 6px 10px rgba(0,0,0,.25))}
.linkHit{stroke:rgba(245,158,11,.25);stroke-width:14;fill:none}

/* Canvas (drawing) */
#drawCanvas{position:absolute;inset:0;touch-action:none;pointer-events:none}

/* Selection rectangle */
#marquee{position:absolute;border:1px dashed var(--snap);background:rgba(245,158,11,.10);display:none;pointer-events:none;z-index:9998}

/* Guides */
.guide{position:absolute;display:none;background:var(--snap);z-index:9999;opacity:.95}
#vGuide{width:2px;top:0;bottom:0}
#hGuide{height:2px;left:0;right:0}

/* Elements */
.el{position:absolute;touch-action:none;user-select:none}
.el .box{
  width:100%;height:100%;
  border-radius:16px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.14);
  box-shadow:0 16px 40px rgba(0,0,0,.35);
  overflow:hidden;
}
.el.note .box{background:rgba(255,246,204,.95);border-color:rgba(0,0,0,.06);box-shadow:0 16px 34px rgba(0,0,0,.22)}
.el.code .box{background:rgba(11,18,32,.94);border-color:rgba(255,255,255,.10)}
.el.selected .box{outline:2px solid var(--brand);outline-offset:2px}
.hdr{
  padding:8px 10px;
  display:flex;align-items:center;gap:8px;
  font-weight:900;font-size:12px;
  color:#fff;background:rgba(0,0,0,.32)
}
.el.note .hdr{color:#111827;background:rgba(0,0,0,.08)}
.el.code .hdr{background:rgba(255,255,255,.06);color:var(--codeink)}
.hdr .title{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.hdr .mini{display:flex;gap:6px;align-items:center}
.hdr .mini button{
  padding:5px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.18);
  background:rgba(0,0,0,.22);color:#fff;cursor:pointer;font-weight:900
}
.el.note .hdr .mini button{background:rgba(255,255,255,.55);color:#111827;border-color:rgba(0,0,0,.10)}
.el.code .hdr .mini button{background:rgba(0,0,0,.25)}
.content{padding:10px}
.content textarea{
  width:100%;height:100%;
  border:0;outline:0;resize:none;
  background:transparent;
  color:#111827;
  font-size:14px;line-height:1.35;
}
.el.code .content textarea{
  color:var(--codeink);
  font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  font-size:13px;
}
.el.code .content{height:calc(100% - 38px)}
.el.note .content{height:calc(100% - 38px)}

/* Handles */
.handles{position:absolute;inset:-10px;display:none;pointer-events:none}
.el.selected .handles{display:block}
.handle{
  position:absolute;width:12px;height:12px;border-radius:999px;
  background:var(--brand2);border:2px solid #111827;
  pointer-events:auto;cursor:pointer;
  box-shadow:0 10px 18px rgba(0,0,0,.25)
}
.handle.nw{left:0;top:0;transform:translate(-50%,-50%);cursor:nwse-resize}
.handle.n{left:50%;top:0;transform:translate(-50%,-50%);cursor:ns-resize}
.handle.ne{right:0;top:0;transform:translate(50%,-50%);cursor:nesw-resize}
.handle.e{right:0;top:50%;transform:translate(50%,-50%);cursor:ew-resize}
.handle.se{right:0;bottom:0;transform:translate(50%,50%);cursor:nwse-resize}
.handle.s{left:50%;bottom:0;transform:translate(-50%,50%);cursor:ns-resize}
.handle.sw{left:0;bottom:0;transform:translate(-50%,50%);cursor:nesw-resize}
.handle.w{left:0;top:50%;transform:translate(-50%,-50%);cursor:ew-resize}
.rotateHandle{
  position:absolute;left:50%;top:-26px;transform:translateX(-50%);
  width:14px;height:14px;border-radius:999px;background:var(--snap);
  border:2px solid #111827;pointer-events:auto;cursor:grab
}
.rotateLine{
  position:absolute;left:50%;top:-10px;transform:translateX(-50%);
  width:2px;height:16px;background:var(--snap);border-radius:999px;opacity:.9
}

/* Floating toolbar inside fullscreen */
#floatBar{
  position:absolute;left:12px;top:12px;
  display:none;gap:8px;align-items:center;flex-wrap:wrap;
  z-index:10000;
  padding:10px;border-radius:16px;
  background:rgba(255,255,255,.12);
  border:1px solid rgba(255,255,255,.18);
  backdrop-filter: blur(8px);
}
#floatBar .iconBtn{background:rgba(255,255,255,.16);color:#fff;border-color:rgba(255,255,255,.18)}
#floatBar .pill{background:rgba(255,255,255,.14);border-color:rgba(255,255,255,.18);color:#fff}
#floatBar label{color:#fff}

/* Help modal */
#helpModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:20000}
#helpModal.show{display:flex}
#helpModal .backdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
#helpModal .panel{
  position:relative;
  width:min(860px,92vw);
  max-height:82vh;
  overflow:auto;
  border-radius:18px;
  background:#fff;
  border:1px solid var(--border);
  box-shadow:0 26px 70px rgba(0,0,0,.35);
  padding:14px;
}
#helpModal h2{margin:0 0 8px;color:var(--brand)}
#helpModal .closeX{
  position:absolute;right:12px;top:10px;
  border:1px solid var(--border);
  background:#fff;
  border-radius:12px;
  padding:6px 10px;
  cursor:pointer;
  font-weight:900;
}
#helpModal ul{margin:8px 0 0 18px}
#helpModal li{margin:6px 0;color:var(--ink)}
#helpModal .muted{color:var(--muted)}

/* FULLSCREEN */
:fullscreen #boardShell,
:-webkit-full-screen #boardShell{
  width:100vw!important;
  height:100vh!important;
  aspect-ratio:auto!important;
  border-radius:0!important;
}
:fullscreen #floatBar,
:-webkit-full-screen #floatBar{display:flex}

@media(max-width:1150px){.grid{grid-template-columns:1fr}}
</style>
</head>

<body>
<div class="wrap">
  <h1>ðŸ§  Programmer's Picnic Whiteboard.</h1>

  <div class="grid">
    <!-- LEFT PANEL -->
    <div class="card">
      <div class="stack">
        <div class="row">
          <!-- Fullscreen button already exists; keep it -->
          <button class="iconBtn" id="fsToggle" title="Fullscreen (F)">â›¶</button>

          <!-- NEW: Help button -->
          <button class="iconBtn" id="helpBtn" title="Help">?</button>

          <div class="pill">
            <span class="badge">Mode</span>
            <select id="modeSel" class="pill" style="padding:6px 10px;border-radius:999px">
              <option value="select">Select / Move</option>
              <option value="draw">Draw</option>
              <option value="connect">Connect</option>
            </select>
          </div>

          <div class="sep"></div>

          <button class="iconBtn" id="undoBtn" title="Undo (Ctrl+Z)">â†¶</button>
          <button class="iconBtn" id="redoBtn" title="Redo (Ctrl+Y)">â†·</button>
        </div>

        <div class="row tight">
          <label class="pill"><input type="checkbox" id="gridToggle"> Grid</label>
          <label class="pill"><input type="checkbox" id="snapToggle" checked> Snap</label>
          <label class="pill"><input type="checkbox" id="safeToggle" checked> Keep in board</label>
        </div>

        <hr>

        <div class="row">
          <button class="btn primary" id="addNoteBtn">âž• Note</button>
          <button class="btn secondary" id="addCodeBtn">âž• Code</button>
          <button class="btn secondary" id="addBoxBtn">âž• Box</button>
        </div>

        <div class="row">
          <button class="btn secondary" id="bringFrontBtn">â¬† Bring Front</button>
          <button class="btn secondary" id="sendBackBtn">â¬‡ Send Back</button>
        </div>

        <div class="row">
          <button class="btn secondary" id="alignLeftBtn">â«· Left</button>
          <button class="btn secondary" id="alignCenterBtn">â‡¤â‡¥ Center</button>
          <button class="btn secondary" id="alignRightBtn">Right â«¸</button>
        </div>
        <div class="row">
          <button class="btn secondary" id="alignTopBtn">â«· Top</button>
          <button class="btn secondary" id="alignMiddleBtn">â‡³ Middle</button>
          <button class="btn secondary" id="alignBottomBtn">Bottom â«¸</button>
        </div>

        <hr>

        <div id="drawTools" class="stack" style="display:none">
          <div class="row">
            <span class="badge">Tool</span>
            <select id="penTool" class="pill" style="padding:6px 10px;border-radius:999px">
              <option value="pen">Pen</option>
              <option value="eraser">Eraser</option>
            </select>
            <span class="badge">Size</span>
            <input id="penSize" type="range" min="2" max="30" value="6" style="width:140px">
          </div>
          <div class="row">
            <span class="badge">Color</span>
            <input id="penColor" type="color" value="#f59e0b" />
            <button class="btn danger" id="clearDrawBtn">Clear Drawing</button>
          </div>
          <small>Tip: hold <kbd>Shift</kbd> to draw straight segments (pen).</small>
        </div>

        <div id="connectHint" style="display:none">
          <small>Connect mode: click one element, then click another to create a link.</small>
          <small>Tip: select a link and press <kbd>Del</kbd> to delete it.</small>
        </div>

        <hr>

        <div class="row">
          <button class="btn secondary" id="exportJsonBtn">Export JSON</button>
          <button class="btn secondary" id="importJsonBtn">Import JSON</button>
          <input type="file" id="importFile" accept="application/json" style="display:none">
        </div>

        <div class="row">
          <button class="btn primary" id="exportPngBtn">Export PNG</button>
          <button class="btn secondary" id="resetBtn" title="Reset everything">Reset</button>
          <!-- NEW: Clear All button (does NOT clear localStorage key; just clears board contents) -->
          <button class="btn danger" id="clearAllBtn" title="Clear everything on the board">Clear All</button>
        </div>

        <hr>

        <div class="stack">
          <small>
            Shortcuts: <kbd>F</kbd> fullscreen Â· <kbd>Del</kbd> delete Â· <kbd>Ctrl</kbd>+<kbd>D</kbd> duplicate Â·
            <kbd>Ctrl</kbd>+<kbd>Z</kbd>/<kbd>Y</kbd> undo/redo Â· <kbd>Shift</kbd> multi-select.
          </small>
          <small>Auto-saves locally (including changes made in fullscreen).</small>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="card boardWrap">
      <div id="boardShell">
        <div id="board" class="gridOn">
          <svg id="linksSvg"></svg>
          <canvas id="drawCanvas"></canvas>
          <div id="marquee"></div>
          <div id="vGuide" class="guide"></div>
          <div id="hGuide" class="guide"></div>

          <!-- Floating toolbar (appears in fullscreen) -->
          <div id="floatBar">
            <button class="iconBtn" id="fsToggle2" title="Exit Fullscreen (F)">â¤¢</button>
            <!-- NEW: Help + Clear All in fullscreen -->
            <button class="iconBtn" id="helpBtn2" title="Help">?</button>
            <button class="iconBtn" id="clearAllBtn2" title="Clear All">ðŸ§¹</button>

            <div class="pill">
              <span class="badge">Mode</span>
              <select id="modeSel2" class="pill" style="padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.14);border-color:rgba(255,255,255,.18);color:#fff">
                <option value="select">Select</option>
                <option value="draw">Draw</option>
                <option value="connect">Connect</option>
              </select>
            </div>
            <label class="pill"><input type="checkbox" id="gridToggle2"> Grid</label>
            <label class="pill"><input type="checkbox" id="snapToggle2" checked> Snap</label>
            <button class="iconBtn" id="addNoteBtn2">+ Note</button>
            <button class="iconBtn" id="addCodeBtn2">+ Code</button>
            <button class="iconBtn" id="exportPngBtn2">PNG</button>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- HELP MODAL -->
<div id="helpModal" aria-hidden="true">
  <div class="backdrop"></div>
  <div class="panel" role="dialog" aria-modal="true" aria-label="Help">
    <button class="closeX" id="helpCloseBtn" title="Close (Esc)">âœ•</button>
    <h2>Whiteboard Help</h2>
    <div class="muted">Everything autosaves. You can safely edit in fullscreen too.</div>

    <hr>

    <h3 style="margin:10px 0 6px;color:var(--brand)">Modes</h3>
    <ul>
      <li><b>Select / Move</b>: click to select, drag to move. Use <kbd>Shift</kbd> for multi-select or marquee selection.</li>
      <li><b>Draw</b>: draw on the canvas. Choose Pen/Eraser, size and color. Hold <kbd>Shift</kbd> to draw straight segments.</li>
      <li><b>Connect</b>: click one element then another to create a link. Click a link to select it, then press <kbd>Del</kbd> to delete.</li>
    </ul>

    <h3 style="margin:12px 0 6px;color:var(--brand)">Editing</h3>
    <ul>
      <li>Resize: use the corner/edge handles on a selected element.</li>
      <li>Rotate: use the top rotate handle (hold <kbd>Shift</kbd> to snap rotation).</li>
      <li>Duplicate: <kbd>Ctrl</kbd>+<kbd>D</kbd></li>
      <li>Undo/Redo: <kbd>Ctrl</kbd>+<kbd>Z</kbd> / <kbd>Ctrl</kbd>+<kbd>Y</kbd></li>
      <li>Fullscreen: click the fullscreen button or press <kbd>F</kbd></li>
      <li>Clear All: removes all elements, links, and drawings from the board (keeps settings).</li>
    </ul>

    <h3 style="margin:12px 0 6px;color:var(--brand)">Export</h3>
    <ul>
      <li><b>Export PNG</b>: downloads the current board as an image.</li>
      <li><b>Export/Import JSON</b>: save/load the full board state.</li>
    </ul>
  </div>
</div>

<script>
(() => {
  /* =========================
     Utilities
  ========================= */
  const $ = (q, root=document) => root.querySelector(q);
  const $$ = (q, root=document) => Array.from(root.querySelectorAll(q));
  const uid = () => "el_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rad = d => d * Math.PI / 180;
  const deg = r => r * 180 / Math.PI;
  const snapVal = (v, step) => Math.round(v / step) * step;

  function download(filename, text, mime="text/plain"){
    const a = document.createElement("a");
    a.href = URL.createObjectURL(new Blob([text], {type:mime}));
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
  }

  /* =========================
     DOM
  ========================= */
  const boardShell = $("#boardShell");
  const board = $("#board");
  const linksSvg = $("#linksSvg");
  const drawCanvas = $("#drawCanvas");
  const ctx = drawCanvas.getContext("2d");
  const vGuide = $("#vGuide"), hGuide = $("#hGuide");
  const marquee = $("#marquee");

  const fsBtn = $("#fsToggle"), fsBtn2 = $("#fsToggle2");
  const modeSel = $("#modeSel"), modeSel2 = $("#modeSel2");

  const gridToggle = $("#gridToggle"), gridToggle2 = $("#gridToggle2");
  const snapToggle = $("#snapToggle"), snapToggle2 = $("#snapToggle2");
  const safeToggle = $("#safeToggle");

  const addNoteBtn = $("#addNoteBtn"), addCodeBtn = $("#addCodeBtn"), addBoxBtn = $("#addBoxBtn");
  const addNoteBtn2 = $("#addNoteBtn2"), addCodeBtn2 = $("#addCodeBtn2");
  const exportPngBtn = $("#exportPngBtn"), exportPngBtn2 = $("#exportPngBtn2");

  const undoBtn = $("#undoBtn"), redoBtn = $("#redoBtn");
  const bringFrontBtn = $("#bringFrontBtn"), sendBackBtn = $("#sendBackBtn");

  const alignLeftBtn = $("#alignLeftBtn"), alignCenterBtn = $("#alignCenterBtn"), alignRightBtn = $("#alignRightBtn");
  const alignTopBtn = $("#alignTopBtn"), alignMiddleBtn = $("#alignMiddleBtn"), alignBottomBtn = $("#alignBottomBtn");

  const exportJsonBtn = $("#exportJsonBtn"), importJsonBtn = $("#importJsonBtn"), importFile = $("#importFile");
  const resetBtn = $("#resetBtn");

  const drawTools = $("#drawTools");
  const connectHint = $("#connectHint");
  const penTool = $("#penTool"), penSize = $("#penSize"), penColor = $("#penColor"), clearDrawBtn = $("#clearDrawBtn");

  /* NEW: Clear All + Help */
  const clearAllBtn = $("#clearAllBtn"), clearAllBtn2 = $("#clearAllBtn2");
  const helpBtn = $("#helpBtn"), helpBtn2 = $("#helpBtn2");
  const helpModal = $("#helpModal"), helpCloseBtn = $("#helpCloseBtn");

  /* =========================
     State (single source of truth)
  ========================= */
  const LS_KEY = "pp_whiteboard_pro_v1";

  const state = {
    meta:{version:1},
    settings:{
      gridOn:true,
      snapOn:true,
      safeOn:true,
      gridSize:30,
      snapDist:8
    },
    els:[],     // {id,type,x,y,w,h,rot,z,title,text}
    links:[],   // {id,from,to}
    strokes:[]  // {tool,color,size,points:[{x,y,shiftSeg?:boolean}]}
  };

  let mode = "select"; // select | draw | connect
  let selectedIds = new Set();
  let selectedLinkId = null;

  let zTop = 10;

  /* =========================
     History (undo/redo)
  ========================= */
  const history = {
    undo:[],
    redo:[],
    limit:80
  };

  function snapshot(){
    const snap = JSON.stringify(state);
    if(history.undo.length && history.undo[history.undo.length-1] === snap) return;
    history.undo.push(snap);
    if(history.undo.length > history.limit) history.undo.shift();
    history.redo.length = 0;
    updateUndoRedoUI();
    scheduleSave();
  }
  function restoreFrom(json){
    const obj = JSON.parse(json);
    Object.assign(state, obj);
    // re-normalize zTop
    zTop = Math.max(10, ...state.els.map(e=>e.z||0), 10);
    applySettingsToUI();
    rerenderAll();
    updateUndoRedoUI();
    scheduleSave(true);
  }
  function undo(){
    if(history.undo.length <= 1) return;
    const cur = history.undo.pop();
    history.redo.push(cur);
    const prev = history.undo[history.undo.length-1];
    restoreFrom(prev);
  }
  function redo(){
    if(!history.redo.length) return;
    const next = history.redo.pop();
    history.undo.push(next);
    restoreFrom(next);
  }
  function updateUndoRedoUI(){
    undoBtn.disabled = history.undo.length <= 1;
    redoBtn.disabled = history.redo.length === 0;
    undoBtn.style.opacity = undoBtn.disabled ? .5 : 1;
    redoBtn.style.opacity = redoBtn.disabled ? .5 : 1;
  }

  /* =========================
     Save / Load (auto)
  ========================= */
  let saveTimer = null;
  function scheduleSave(force=false){
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      try{
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      }catch(e){}
    }, force ? 0 : 250);
  }
  function load(){
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return false;
    try{
      const obj = JSON.parse(raw);
      Object.assign(state, obj);
      zTop = Math.max(10, ...state.els.map(e=>e.z||0), 10);
      return true;
    }catch(e){
      return false;
    }
  }

  /* =========================
     Canvas sizing (HiDPI)
  ========================= */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resizeCanvas(){
    const r = board.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    drawCanvas.width = Math.floor(r.width * DPR);
    drawCanvas.height = Math.floor(r.height * DPR);
    drawCanvas.style.width = r.width + "px";
    drawCanvas.style.height = r.height + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
    redrawStrokes();
    redrawLinks();
  }
  window.addEventListener("resize", resizeCanvas);

  /* =========================
     Settings UI
  ========================= */
  function applySettingsToUI(){
    board.classList.toggle("gridOn", !!state.settings.gridOn);
    gridToggle.checked = !!state.settings.gridOn;
    gridToggle2.checked = !!state.settings.gridOn;

    snapToggle.checked = !!state.settings.snapOn;
    snapToggle2.checked = !!state.settings.snapOn;

    safeToggle.checked = !!state.settings.safeOn;
  }
  function setMode(newMode){
    mode = newMode;
    modeSel.value = newMode;
    modeSel2.value = newMode;

    drawTools.style.display = (mode === "draw") ? "block" : "none";
    connectHint.style.display = (mode === "connect") ? "block" : "none";

    // drawing canvas pointer events only in draw mode
    drawCanvas.style.pointerEvents = (mode === "draw") ? "auto" : "none";

    // clear connect selection
    if(mode !== "connect"){
      connectFrom = null;
    }
  }

  /* =========================
     Element creation
  ========================= */
  function addElement(type, x=60, y=60){
    const id = uid();
    const base = {
      id, type,
      x, y,
      w: type==="note" ? 320 : (type==="code" ? 380 : 260),
      h: type==="note" ? 220 : (type==="code" ? 260 : 180),
      rot:0,
      z: ++zTop,
      title: type==="note" ? "Note" : (type==="code" ? "Code" : "Box"),
      text: type==="note" ? "Write hereâ€¦" : (type==="code" ? "// Write code here\n" : "Textâ€¦")
    };
    state.els.push(base);
    selectOnly(id);
    rerenderAll();
    snapshot();
    return id;
  }

  /* =========================
     Render elements
  ========================= */
  const elDom = new Map(); // id -> dom
  function makeElDOM(e){
    const el = document.createElement("div");
    el.className = "el " + e.type;
    el.dataset.id = e.id;

    el.innerHTML = `
      <div class="box">
        <div class="hdr">
          <span class="title"></span>
          <div class="mini">
            <button data-act="dup" title="Duplicate (Ctrl+D)">âŽ˜</button>
            <button data-act="del" title="Delete (Del)">âœ•</button>
          </div>
        </div>
        <div class="content">
          <textarea spellcheck="false"></textarea>
        </div>
      </div>
      <div class="handles">
        <div class="rotateLine"></div>
        <div class="rotateHandle" data-h="rot"></div>
        <div class="handle nw" data-h="nw"></div>
        <div class="handle n" data-h="n"></div>
        <div class="handle ne" data-h="ne"></div>
        <div class="handle e" data-h="e"></div>
        <div class="handle se" data-h="se"></div>
        <div class="handle s" data-h="s"></div>
        <div class="handle sw" data-h="sw"></div>
        <div class="handle w" data-h="w"></div>
      </div>
    `;

    const titleEl = $(".title", el);
    const ta = $("textarea", el);

    titleEl.textContent = e.title;
    ta.value = e.text;

    ta.addEventListener("pointerdown", (ev) => { ev.stopPropagation(); });
    ta.addEventListener("input", () => {
      const m = getEl(e.id);
      if(!m) return;
      m.text = ta.value;
      scheduleSave();
    });

    $(".mini", el).addEventListener("click", (ev) => {
      const btn = ev.target.closest("button");
      if(!btn) return;
      ev.stopPropagation();
      const act = btn.dataset.act;
      if(act === "del"){ deleteSelection(); }
      if(act === "dup"){ duplicateSelection(); }
    });

    el.addEventListener("pointerdown", (ev) => {
      const id = e.id;
      const handle = ev.target.closest("[data-h]");
      const isHandle = !!handle;

      if(mode === "draw"){ return; }

      if(mode === "connect" && !isHandle){
        ev.preventDefault();
        handleConnectClick(id);
        return;
      }

      ev.preventDefault();
      if(ev.shiftKey){
        toggleSelect(id);
      }else{
        if(!selectedIds.has(id)) selectOnly(id);
      }

      selectedLinkId = null;
      updateLinkSelectionUI();

      const action = isHandle ? handle.dataset.h : "move";
      startManipulation(ev, id, action);
    });

    el.addEventListener("click", (ev) => {
      if(mode !== "select") return;
      const id = e.id;
      if(ev.shiftKey) toggleSelect(id);
      else if(!selectedIds.has(id)) selectOnly(id);
    });

    board.appendChild(el);
    elDom.set(e.id, el);
    return el;
  }

  function getEl(id){ return state.els.find(x => x.id === id); }
  function applyElStyle(e){
    const el = elDom.get(e.id);
    if(!el) return;
    el.style.zIndex = e.z;
    el.style.left = e.x + "px";
    el.style.top = e.y + "px";
    el.style.width = e.w + "px";
    el.style.height = e.h + "px";
    el.style.transform = `rotate(${e.rot}deg)`;
    el.classList.toggle("selected", selectedIds.has(e.id));

    const titleEl = $(".title", el);
    if(titleEl.textContent !== e.title) titleEl.textContent = e.title;
  }

  function rerenderAll(){
    const existing = new Set(elDom.keys());
    for(const e of state.els){
      if(!elDom.has(e.id)) makeElDOM(e);
      applyElStyle(e);
      existing.delete(e.id);
      const el = elDom.get(e.id);
      const ta = $("textarea", el);
      if(document.activeElement !== ta && ta.value !== e.text) ta.value = e.text;
    }
    for(const id of existing){
      const el = elDom.get(id);
      if(el){ el.remove(); }
      elDom.delete(id);
    }

    redrawLinks();
    redrawStrokes();
    updateSelectionUI();
  }

  function updateSelectionUI(){
    $$(".el").forEach(el => el.classList.toggle("selected", selectedIds.has(el.dataset.id)));
  }

  /* =========================
     Selection helpers
  ========================= */
  function selectOnly(id){
    selectedIds.clear();
    selectedIds.add(id);
    updateSelectionUI();
  }
  function toggleSelect(id){
    if(selectedIds.has(id)) selectedIds.delete(id);
    else selectedIds.add(id);
    updateSelectionUI();
  }
  function clearSelection(){
    selectedIds.clear();
    selectedLinkId = null;
    updateSelectionUI();
    updateLinkSelectionUI();
  }

  /* =========================
     Snap + Guides
  ========================= */
  function showGuides(x=null, y=null){
    if(x !== null){
      vGuide.style.display = "block";
      vGuide.style.left = x + "px";
    }else vGuide.style.display = "none";

    if(y !== null){
      hGuide.style.display = "block";
      hGuide.style.top = y + "px";
    }else hGuide.style.display = "none";
  }
  function hideGuides(){ showGuides(null, null); }

  function applySnap(x,y,w,h,excludeIds=new Set()){
    if(!state.settings.snapOn) return {x,y,w,h, gx:null, gy:null};

    const g = state.settings.gridSize;
    const d = state.settings.snapDist;

    let gx = null, gy = null;

    const xg = snapVal(x, g), yg = snapVal(y, g);
    if(Math.abs(x - xg) <= d){ x = xg; gx = xg; }
    if(Math.abs(y - yg) <= d){ y = yg; gy = yg; }

    const candidates = state.els.filter(e => !excludeIds.has(e.id));
    const my = {l:x, r:x+w, t:y, b:y+h, cx:x+w/2, cy:y+h/2};

    function trySnap(val, target){
      return Math.abs(val - target) <= d ? target : null;
    }

    let snapX = null, snapY = null;

    for(const e of candidates){
      const r = {l:e.x, r:e.x+e.w, t:e.y, b:e.y+e.h, cx:e.x+e.w/2, cy:e.y+e.h/2};
      const targetsX = [r.l, r.r, r.cx];
      const targetsY = [r.t, r.b, r.cy];

      for(const tx of targetsX){
        const s1 = trySnap(my.l, tx);
        const s2 = trySnap(my.r, tx);
        const s3 = trySnap(my.cx, tx);
        if(s1 !== null){ x = tx; snapX = tx; }
        if(s2 !== null){ x = tx - w; snapX = tx; }
        if(s3 !== null){ x = tx - w/2; snapX = tx; }
      }
      for(const ty of targetsY){
        const s1 = trySnap(my.t, ty);
        const s2 = trySnap(my.b, ty);
        const s3 = trySnap(my.cy, ty);
        if(s1 !== null){ y = ty; snapY = ty; }
        if(s2 !== null){ y = ty - h; snapY = ty; }
        if(s3 !== null){ y = ty - h/2; snapY = ty; }
      }
    }

    gx = snapX !== null ? snapX : gx;
    gy = snapY !== null ? snapY : gy;

    return {x,y,w,h,gx,gy};
  }

  function keepInBoard(e){
    if(!state.settings.safeOn) return;
    const r = board.getBoundingClientRect();
    e.x = clamp(e.x, 0, r.width - e.w);
    e.y = clamp(e.y, 0, r.height - e.h);
  }

  /* =========================
     Manipulation (move/resize/rotate)
  ========================= */
  let drag = null;

  function startManipulation(ev, id, action){
    const base = getEl(id);
    if(!base) return;

    const ids = Array.from(selectedIds);
    const items = ids.map(i => ({ id:i, ref:getEl(i), start:null })).filter(x=>x.ref);

    const boardRect = board.getBoundingClientRect();
    const px = ev.clientX - boardRect.left;
    const py = ev.clientY - boardRect.top;

    for(const it of items){
      it.start = {x:it.ref.x, y:it.ref.y, w:it.ref.w, h:it.ref.h, rot:it.ref.rot};
    }

    drag = {
      pointerId: ev.pointerId,
      action, primaryId: id,
      startPX: px, startPY: py,
      items,
      base: {x:base.x,y:base.y,w:base.w,h:base.h,rot:base.rot}
    };

    board.setPointerCapture(ev.pointerId);
  }

  function onManipMove(ev){
    if(!drag) return;
    const boardRect = board.getBoundingClientRect();
    const px = ev.clientX - boardRect.left;
    const py = ev.clientY - boardRect.top;

    const dx = px - drag.startPX;
    const dy = py - drag.startPY;

    const action = drag.action;
    const primary = getEl(drag.primaryId);
    if(!primary) return;

    const exclude = new Set(drag.items.map(x=>x.id));

    if(action === "move"){
      const p0 = drag.items.find(x=>x.id === drag.primaryId) || drag.items[0];
      const start = p0.start;

      let x = start.x + dx;
      let y = start.y + dy;

      const snapped = applySnap(x, y, primary.w, primary.h, exclude);
      const sx = snapped.x, sy = snapped.y;

      for(const it of drag.items){
        it.ref.x = it.start.x + (sx - start.x);
        it.ref.y = it.start.y + (sy - start.y);
        keepInBoard(it.ref);
      }
      if(snapped.gx !== null || snapped.gy !== null) showGuides(snapped.gx, snapped.gy);
      else hideGuides();

      rerenderAll();
      return;
    }

    if(action === "rot"){
      const cx = primary.x + primary.w/2;
      const cy = primary.y + primary.h/2;
      const ang = Math.atan2(py - cy, px - cx);
      const ang0 = Math.atan2(drag.startPY - cy, drag.startPX - cx);
      let dAng = deg(ang - ang0);
      let newRot = drag.base.rot + dAng;
      if(ev.shiftKey){
        newRot = Math.round(newRot / 15) * 15;
      }
      primary.rot = newRot;
      rerenderAll();
      hideGuides();
      return;
    }

    const s = drag.base;
    let x = s.x, y = s.y, w = s.w, h = s.h;

    const keepAspect = ev.shiftKey;
    const aspect = s.w / Math.max(1,s.h);

    function resizeFrom(handle){
      let nx=x, ny=y, nw=w, nh=h;
      const minW = 120, minH = 90;

      if(handle.includes("e")) nw = w + dx;
      if(handle.includes("s")) nh = h + dy;
      if(handle.includes("w")) { nw = w - dx; nx = x + dx; }
      if(handle.includes("n")) { nh = h - dy; ny = y + dy; }

      nw = Math.max(minW, nw);
      nh = Math.max(minH, nh);

      if(keepAspect){
        if(Math.abs(dx) > Math.abs(dy)) nh = Math.round(nw / aspect);
        else nw = Math.round(nh * aspect);
        if(handle.includes("w")) nx = x + (w - nw);
        if(handle.includes("n")) ny = y + (h - nh);
      }

      if(state.settings.snapOn){
        const g = state.settings.gridSize;
        const d = state.settings.snapDist;

        const nxg = snapVal(nx, g);
        const nyg = snapVal(ny, g);
        const nwg = snapVal(nw, g);
        const nhg = snapVal(nh, g);

        let gx=null, gy=null;

        if(Math.abs(nx - nxg) <= d){ nx = nxg; gx = nxg; }
        if(Math.abs(ny - nyg) <= d){ ny = nyg; gy = nyg; }
        if(Math.abs(nw - nwg) <= d){ nw = Math.max(minW, nwg); }
        if(Math.abs(nh - nhg) <= d){ nh = Math.max(minH, nhg); }

        const snapped = applySnap(nx, ny, nw, nh, exclude);
        nx = snapped.x; ny = snapped.y; nw = snapped.w; nh = snapped.h;
        gx = snapped.gx ?? gx;
        gy = snapped.gy ?? gy;

        if(gx !== null || gy !== null) showGuides(gx, gy); else hideGuides();
      }else hideGuides();

      primary.x = nx; primary.y = ny; primary.w = nw; primary.h = nh;
      keepInBoard(primary);
    }

    resizeFrom(action);
    rerenderAll();
  }

  function endManipulation(){
    if(!drag) return;
    drag = null;
    hideGuides();
    snapshot();
  }

  board.addEventListener("pointermove", onManipMove);
  board.addEventListener("pointerup", (ev) => { if(drag && ev.pointerId === drag.pointerId) endManipulation(); });
  board.addEventListener("pointercancel", (ev) => { if(drag && ev.pointerId === drag.pointerId) endManipulation(); });

  /* =========================
     Links (connectors)
  ========================= */
  let connectFrom = null;

  function anchor(id){
    const e = getEl(id);
    if(!e) return {x:0,y:0};
    return {x: e.x + e.w/2, y: e.y + e.h/2};
  }

  function handleConnectClick(id){
    if(!connectFrom){
      connectFrom = id;
      selectOnly(id);
      return;
    }
    if(connectFrom === id){
      connectFrom = null;
      return;
    }
    const exists = state.links.some(l => (l.from===connectFrom && l.to===id) || (l.from===id && l.to===connectFrom));
    if(!exists){
      state.links.push({id: uid(), from: connectFrom, to: id});
      snapshot();
    }
    connectFrom = null;
    rerenderAll();
  }

  function redrawLinks(){
    linksSvg.setAttribute("width","100%");
    linksSvg.setAttribute("height","100%");
    linksSvg.innerHTML = "";

    for(const l of state.links){
      const a = anchor(l.from), b = anchor(l.to);
      const dx = Math.abs(b.x - a.x);
      const c = Math.max(60, Math.min(220, dx * 0.35));
      const d = `M ${a.x} ${a.y} C ${a.x + c} ${a.y}, ${b.x - c} ${b.y}, ${b.x} ${b.y}`;

      const hit = document.createElementNS("http://www.w3.org/2000/svg","path");
      hit.setAttribute("d", d);
      hit.setAttribute("class","linkHit");
      hit.style.pointerEvents = "auto";
      hit.style.cursor = "pointer";
      hit.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        selectedLinkId = l.id;
        clearSelection();
        selectedLinkId = l.id;
        updateLinkSelectionUI();
      });

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("class","link");
      path.style.opacity = (selectedLinkId === l.id) ? "1" : ".92";
      if(selectedLinkId === l.id){
        path.style.stroke = "rgba(255,255,255,.95)";
        path.style.filter = "drop-shadow(0 10px 18px rgba(245,158,11,.30))";
      }

      linksSvg.appendChild(hit);
      linksSvg.appendChild(path);
    }
  }

  function updateLinkSelectionUI(){
    redrawLinks();
  }

  /* =========================
     Drawing (strokes)
  ========================= */
  let draw = null;

  function boardXYFromEvent(ev){
    const r = board.getBoundingClientRect();
    return {x: ev.clientX - r.left, y: ev.clientY - r.top};
  }

  function redrawStrokes(){
    const r = board.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);
    for(const s of state.strokes){
      paintStroke(s);
    }
  }

  function paintStroke(s){
    if(!s.points || s.points.length < 1) return;
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    if(s.tool === "eraser"){
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    }else{
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = s.color || "#f59e0b";
    }
    ctx.lineWidth = s.size || 6;

    const pts = s.points;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){
      const p = pts[i];
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function startDraw(ev){
    if(mode !== "draw") return;
    ev.preventDefault();
    selectedLinkId = null;
    updateLinkSelectionUI();
    board.focus?.();

    const {x,y} = boardXYFromEvent(ev);
    draw = {
      pointerId: ev.pointerId,
      tool: penTool.value,
      color: penColor.value,
      size: Number(penSize.value),
      shift: ev.shiftKey,
      stroke: {tool: penTool.value, color: penColor.value, size: Number(penSize.value), points:[{x,y}]}
    };
    drawCanvas.setPointerCapture(ev.pointerId);
  }

  function moveDraw(ev){
    if(!draw || ev.pointerId !== draw.pointerId) return;
    ev.preventDefault();
    const {x,y} = boardXYFromEvent(ev);

    const pts = draw.stroke.points;
    const last = pts[pts.length-1];

    if(ev.shiftKey && penTool.value === "pen"){
      const dx = Math.abs(x - pts[0].x);
      const dy = Math.abs(y - pts[0].y);
      if(dx > dy) pts.push({x, y: pts[0].y});
      else pts.push({x: pts[0].x, y});
    }else{
      if(Math.hypot(x-last.x, y-last.y) < 1.4) return;
      pts.push({x,y});
    }

    paintStroke({tool: draw.stroke.tool, color: draw.stroke.color, size: draw.stroke.size, points:[last, pts[pts.length-1]]});
  }

  function endDraw(ev){
    if(!draw || ev.pointerId !== draw.pointerId) return;
    ev.preventDefault();
    if(draw.stroke.points.length > 1){
      state.strokes.push(draw.stroke);
      snapshot();
    }
    draw = null;
  }

  drawCanvas.addEventListener("pointerdown", startDraw);
  drawCanvas.addEventListener("pointermove", moveDraw);
  drawCanvas.addEventListener("pointerup", endDraw);
  drawCanvas.addEventListener("pointercancel", endDraw);

  clearDrawBtn.addEventListener("click", () => {
    if(!state.strokes.length) return;
    state.strokes.length = 0;
    redrawStrokes();
    snapshot();
  });

  /* =========================
     Marquee selection (drag on empty board)
  ========================= */
  let boxSel = null;

  function startMarquee(ev){
    if(mode !== "select") return;
    if(ev.target.closest(".el")) return;
    if(ev.target.closest("svg")) return;
    if(ev.target.closest("#floatBar")) return;

    ev.preventDefault();
    const {x,y} = boardXYFromEvent(ev);

    boxSel = {pointerId: ev.pointerId, x0:x, y0:y, x1:x, y1:y, add: ev.shiftKey};
    marquee.style.display = "block";
    board.setPointerCapture(ev.pointerId);
  }

  function moveMarquee(ev){
    if(!boxSel || ev.pointerId !== boxSel.pointerId) return;
    ev.preventDefault();
    const {x,y} = boardXYFromEvent(ev);
    boxSel.x1 = x; boxSel.y1 = y;

    const rx = Math.min(boxSel.x0, boxSel.x1);
    const ry = Math.min(boxSel.y0, boxSel.y1);
    const rw = Math.abs(boxSel.x1 - boxSel.x0);
    const rh = Math.abs(boxSel.y1 - boxSel.y0);

    marquee.style.left = rx + "px";
    marquee.style.top = ry + "px";
    marquee.style.width = rw + "px";
    marquee.style.height = rh + "px";
  }

  function endMarquee(ev){
    if(!boxSel || ev.pointerId !== boxSel.pointerId) return;
    ev.preventDefault();

    const rx = Math.min(boxSel.x0, boxSel.x1);
    const ry = Math.min(boxSel.y0, boxSel.y1);
    const rw = Math.abs(boxSel.x1 - boxSel.x0);
    const rh = Math.abs(boxSel.y1 - boxSel.y0);
    const rect = {x:rx,y:ry,w:rw,h:rh};

    if(!boxSel.add) selectedIds.clear();

    for(const e of state.els){
      const r = {x:e.x,y:e.y,w:e.w,h:e.h};
      const overlap = !(r.x > rect.x+rect.w || r.x+r.w < rect.x || r.y > rect.y+rect.h || r.y+r.h < rect.y);
      if(overlap) selectedIds.add(e.id);
    }

    marquee.style.display = "none";
    boxSel = null;
    updateSelectionUI();
  }

  board.addEventListener("pointerdown", startMarquee);
  board.addEventListener("pointermove", moveMarquee);
  board.addEventListener("pointerup", endMarquee);
  board.addEventListener("pointercancel", endMarquee);

  board.addEventListener("pointerdown", (ev) => {
    if(mode !== "select") return;
    if(ev.target.closest(".el")) return;
    if(ev.target.closest("path")) return;
    if(ev.target.closest("#floatBar")) return;
    if(!ev.shiftKey) clearSelection();
  });

  /* =========================
     Delete / Duplicate / Z-order
  ========================= */
  function deleteSelection(){
    if(selectedLinkId){
      state.links = state.links.filter(l => l.id !== selectedLinkId);
      selectedLinkId = null;
      snapshot();
      rerenderAll();
      return;
    }
    if(!selectedIds.size) return;
    const ids = new Set(selectedIds);
    state.els = state.els.filter(e => !ids.has(e.id));
    state.links = state.links.filter(l => !ids.has(l.from) && !ids.has(l.to));
    clearSelection();
    snapshot();
    rerenderAll();
  }

  function duplicateSelection(){
    if(!selectedIds.size) return;
    const ids = Array.from(selectedIds);
    const created = [];
    for(const id of ids){
      const e = getEl(id);
      if(!e) continue;
      const n = JSON.parse(JSON.stringify(e));
      n.id = uid();
      n.x += 22; n.y += 22;
      n.z = ++zTop;
      state.els.push(n);
      created.push(n.id);
    }
    selectedIds = new Set(created);
    snapshot();
    rerenderAll();
  }

  function bringFront(){
    const ids = Array.from(selectedIds);
    if(!ids.length) return;
    for(const id of ids){
      const e = getEl(id);
      if(e) e.z = ++zTop;
    }
    snapshot();
    rerenderAll();
  }
  function sendBack(){
    const ids = Array.from(selectedIds);
    if(!ids.length) return;
    let zMin = Math.min(...state.els.map(e=>e.z||1), 1);
    for(const id of ids){
      const e = getEl(id);
      if(e) e.z = zMin - 1;
      zMin -= 1;
    }
    const sorted = [...state.els].sort((a,b)=>(a.z||0)-(b.z||0));
    sorted.forEach((e,i)=> e.z = i+1);
    zTop = state.els.length + 10;
    snapshot();
    rerenderAll();
  }

  /* =========================
     Align tools
  ========================= */
  function selectedEls(){
    return state.els.filter(e => selectedIds.has(e.id));
  }
  function alignLeft(){
    const arr = selectedEls(); if(arr.length<2) return;
    const x = Math.min(...arr.map(e=>e.x));
    arr.forEach(e=> e.x = x);
    snapshot(); rerenderAll();
  }
  function alignCenter(){
    const arr = selectedEls(); if(arr.length<2) return;
    const cx = (Math.min(...arr.map(e=>e.x)) + Math.max(...arr.map(e=>e.x+e.w))) / 2;
    arr.forEach(e=> e.x = cx - e.w/2);
    snapshot(); rerenderAll();
  }
  function alignRight(){
    const arr = selectedEls(); if(arr.length<2) return;
    const r = Math.max(...arr.map(e=>e.x+e.w));
    arr.forEach(e=> e.x = r - e.w);
    snapshot(); rerenderAll();
  }
  function alignTop(){
    const arr = selectedEls(); if(arr.length<2) return;
    const y = Math.min(...arr.map(e=>e.y));
    arr.forEach(e=> e.y = y);
    snapshot(); rerenderAll();
  }
  function alignMiddle(){
    const arr = selectedEls(); if(arr.length<2) return;
    const cy = (Math.min(...arr.map(e=>e.y)) + Math.max(...arr.map(e=>e.y+e.h))) / 2;
    arr.forEach(e=> e.y = cy - e.h/2);
    snapshot(); rerenderAll();
  }
  function alignBottom(){
    const arr = selectedEls(); if(arr.length<2) return;
    const b = Math.max(...arr.map(e=>e.y+e.h));
    arr.forEach(e=> e.y = b - e.h);
    snapshot(); rerenderAll();
  }

  /* =========================
     Export PNG (unchanged)
  ========================= */
  function wrapLines(text, maxChars){
    const words = text.replace(/\r/g,"").split(/(\s+)/);
    const lines = [];
    let line = "";
    for(const w of words){
      if((line + w).length > maxChars){
        if(line.trim()) lines.push(line.trimEnd());
        line = w.trimStart();
      }else{
        line += w;
      }
    }
    if(line.trim()) lines.push(line.trimEnd());
    return lines;
  }

  function exportPNG(){
    const r = board.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const out = document.createElement("canvas");
    out.width = Math.floor(r.width * dpr);
    out.height = Math.floor(r.height * dpr);
    const g = out.getContext("2d");
    g.setTransform(dpr,0,0,dpr,0,0);

    g.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--boardbg").trim() || "#0a0a0a";
    g.fillRect(0,0,r.width,r.height);

    if(state.settings.gridOn){
      const gs = state.settings.gridSize;
      g.strokeStyle = "rgba(255,255,255,.08)";
      g.lineWidth = 1;
      for(let x=0;x<=r.width;x+=gs){
        g.beginPath(); g.moveTo(x+.5,0); g.lineTo(x+.5,r.height); g.stroke();
      }
      for(let y=0;y<=r.height;y+=gs){
        g.beginPath(); g.moveTo(0,y+.5); g.lineTo(r.width,y+.5); g.stroke();
      }
    }

    for(const l of state.links){
      const a = anchor(l.from), b = anchor(l.to);
      const dx = Math.abs(b.x - a.x);
      const c = Math.max(60, Math.min(220, dx * 0.35));

      g.strokeStyle = "rgba(245,158,11,.95)";
      g.lineWidth = 3;
      g.beginPath();
      g.moveTo(a.x, a.y);
      g.bezierCurveTo(a.x + c, a.y, b.x - c, b.y, b.x, b.y);
      g.stroke();
    }

    const sorted = [...state.els].sort((a,b)=>(a.z||0)-(b.z||0));
    for(const e of sorted){
      const isNote = e.type==="note";
      const isCode = e.type==="code";

      g.save();
      const cx = e.x + e.w/2, cy = e.y + e.h/2;
      g.translate(cx, cy);
      g.rotate(rad(e.rot||0));
      g.translate(-e.w/2, -e.h/2);

      g.shadowColor = "rgba(0,0,0,.25)";
      g.shadowBlur = 18;
      g.shadowOffsetY = 8;

      g.fillStyle = isNote ? "rgba(255,246,204,.95)" : (isCode ? "rgba(11,18,32,.94)" : "rgba(255,255,255,.10)");
      g.strokeStyle = isNote ? "rgba(0,0,0,.08)" : "rgba(255,255,255,.16)";
      g.lineWidth = 1;
      roundRect(g, 0,0, e.w,e.h, 16);
      g.fill();
      g.shadowBlur = 0; g.shadowOffsetY = 0;
      g.stroke();

      g.fillStyle = isNote ? "rgba(0,0,0,.10)" : (isCode ? "rgba(255,255,255,.07)" : "rgba(0,0,0,.32)");
      roundRect(g, 0,0, e.w, 34, 16, true, false);
      g.fill();

      g.fillStyle = isNote ? "#111827" : "#e5e7eb";
      g.font = "900 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      g.fillText(e.title || (isNote?"Note":isCode?"Code":"Box"), 10, 21);

      const pad = 10;
      const top = 44;
      g.fillStyle = isCode ? "#e5e7eb" : "#111827";
      g.font = isCode ? "13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace" : "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";

      const text = (e.text || "").replace(/\t/g,"  ");
      const maxChars = Math.max(10, Math.floor((e.w - pad*2) / (isCode ? 7.2 : 7.8)));
      const lines = text.split("\n").flatMap(line => line ? wrapLines(line, maxChars) : [""]);
      const maxLines = Math.floor((e.h - top - pad) / (isCode ? 16 : 18));
      for(let i=0;i<Math.min(lines.length, maxLines);i++){
        g.fillText(lines[i], pad, top + i*(isCode?16:18));
      }

      g.restore();
    }

    g.save();
    for(const s of state.strokes){
      g.lineCap = "round";
      g.lineJoin = "round";
      if(s.tool === "eraser"){
        g.globalCompositeOperation = "destination-out";
        g.strokeStyle = "rgba(0,0,0,1)";
      }else{
        g.globalCompositeOperation = "source-over";
        g.strokeStyle = s.color || "#f59e0b";
      }
      g.lineWidth = s.size || 6;
      const pts = s.points || [];
      if(pts.length < 2) continue;
      g.beginPath();
      g.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
      g.stroke();
    }
    g.restore();

    out.toBlob((blob) => {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "whiteboard.png";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
    }, "image/png");
  }

  function roundRect(g,x,y,w,h,r, top=true, bottom=true){
    const tl = top ? r : 0, tr = top ? r : 0, br = bottom ? r : 0, bl = bottom ? r : 0;
    g.beginPath();
    g.moveTo(x+tl, y);
    g.lineTo(x+w-tr, y);
    g.quadraticCurveTo(x+w, y, x+w, y+tr);
    g.lineTo(x+w, y+h-br);
    g.quadraticCurveTo(x+w, y+h, x+w-br, y+h);
    g.lineTo(x+bl, y+h);
    g.quadraticCurveTo(x, y+h, x, y+h-bl);
    g.lineTo(x, y+tl);
    g.quadraticCurveTo(x, y, x+tl, y);
    g.closePath();
  }

  /* =========================
     Export/Import JSON
  ========================= */
  function exportJSON(){
    const payload = JSON.stringify(state, null, 2);
    download("whiteboard.json", payload, "application/json");
  }
  function importJSONText(txt){
    try{
      const obj = JSON.parse(txt);
      if(!obj || !obj.els || !obj.links || !obj.strokes) throw new Error("Invalid file");
      Object.assign(state, obj);
      zTop = Math.max(10, ...state.els.map(e=>e.z||0), 10);
      clearSelection();
      applySettingsToUI();
      rerenderAll();
      history.undo.length = 0;
      history.redo.length = 0;
      history.undo.push(JSON.stringify(state));
      updateUndoRedoUI();
      scheduleSave(true);
    }catch(e){
      alert("Could not import: " + e.message);
    }
  }

  /* =========================
     UI wiring
  ========================= */
  function isFS(){ return document.fullscreenElement; }
  function toggleFS(){
    if(!isFS()) boardShell.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
  function onFSChange(){
    fsBtn.textContent = isFS() ? "â¤¢" : "â›¶";
    if(fsBtn2) fsBtn2.textContent = isFS() ? "â¤¢" : "â›¶";
    resizeCanvas();
  }

  fsBtn.addEventListener("click", toggleFS);
  fsBtn2.addEventListener("click", toggleFS);
  document.addEventListener("fullscreenchange", onFSChange);

  function syncMode(from){
    setMode(from.value);
  }
  modeSel.addEventListener("change", () => syncMode(modeSel));
  modeSel2.addEventListener("change", () => syncMode(modeSel2));

  gridToggle.addEventListener("change", (e) => {
    state.settings.gridOn = e.target.checked;
    applySettingsToUI();
    snapshot();
  });
  gridToggle2.addEventListener("change", (e) => {
    state.settings.gridOn = e.target.checked;
    applySettingsToUI();
    snapshot();
  });

  snapToggle.addEventListener("change", (e) => {
    state.settings.snapOn = e.target.checked;
    applySettingsToUI();
    snapshot();
  });
  snapToggle2.addEventListener("change", (e) => {
    state.settings.snapOn = e.target.checked;
    applySettingsToUI();
    snapshot();
  });

  safeToggle.addEventListener("change", (e) => {
    state.settings.safeOn = e.target.checked;
    snapshot();
  });

  addNoteBtn.addEventListener("click", () => addElement("note", 80, 80));
  addCodeBtn.addEventListener("click", () => addElement("code", 140, 120));
  addBoxBtn.addEventListener("click", () => addElement("box", 220, 160));

  addNoteBtn2.addEventListener("click", () => addElement("note", 80, 80));
  addCodeBtn2.addEventListener("click", () => addElement("code", 140, 120));

  exportPngBtn.addEventListener("click", exportPNG);
  exportPngBtn2.addEventListener("click", exportPNG);

  exportJsonBtn.addEventListener("click", exportJSON);
  importJsonBtn.addEventListener("click", () => importFile.click());
  importFile.addEventListener("change", async () => {
    const f = importFile.files?.[0];
    if(!f) return;
    const txt = await f.text();
    importJSONText(txt);
    importFile.value = "";
  });

  resetBtn.addEventListener("click", () => {
    if(!confirm("Reset everything? This clears local saved board.")) return;
    localStorage.removeItem(LS_KEY);
    state.els.length = 0;
    state.links.length = 0;
    state.strokes.length = 0;
    state.settings.gridOn = true;
    state.settings.snapOn = true;
    state.settings.safeOn = true;
    zTop = 10;
    clearSelection();
    applySettingsToUI();
    rerenderAll();
    history.undo.length = 0;
    history.redo.length = 0;
    history.undo.push(JSON.stringify(state));
    updateUndoRedoUI();
    scheduleSave(true);
  });

  /* NEW: Clear All (keeps settings + keeps autosave) */
  function clearAll(){
    if(!confirm("Clear ALL elements, links, and drawings from the board?")) return;
    state.els.length = 0;
    state.links.length = 0;
    state.strokes.length = 0;
    zTop = 10;
    clearSelection();
    rerenderAll();
    snapshot();
  }
  clearAllBtn.addEventListener("click", clearAll);
  clearAllBtn2.addEventListener("click", clearAll);

  /* NEW: Help modal */
  function openHelp(){
    helpModal.classList.add("show");
    helpModal.setAttribute("aria-hidden","false");
  }
  function closeHelp(){
    helpModal.classList.remove("show");
    helpModal.setAttribute("aria-hidden","true");
  }
  helpBtn.addEventListener("click", openHelp);
  helpBtn2.addEventListener("click", openHelp);
  helpCloseBtn.addEventListener("click", closeHelp);
  $(".backdrop", helpModal).addEventListener("click", closeHelp);

  undoBtn.addEventListener("click", undo);
  redoBtn.addEventListener("click", redo);

  bringFrontBtn.addEventListener("click", bringFront);
  sendBackBtn.addEventListener("click", sendBack);

  alignLeftBtn.addEventListener("click", alignLeft);
  alignCenterBtn.addEventListener("click", alignCenter);
  alignRightBtn.addEventListener("click", alignRight);
  alignTopBtn.addEventListener("click", alignTop);
  alignMiddleBtn.addEventListener("click", alignMiddle);
  alignBottomBtn.addEventListener("click", alignBottom);

  /* Keyboard shortcuts */
  window.addEventListener("keydown", (ev) => {
    const activeTag = (document.activeElement?.tagName || "").toLowerCase();
    const typing = activeTag === "textarea" || activeTag === "input";

    if(ev.key.toLowerCase() === "f" && !ev.ctrlKey && !ev.metaKey && !typing){
      ev.preventDefault();
      toggleFS();
      return;
    }

    if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === "z"){
      ev.preventDefault();
      undo();
      return;
    }
    if((ev.ctrlKey || ev.metaKey) && (ev.key.toLowerCase() === "y" || (ev.shiftKey && ev.key.toLowerCase() === "z"))){
      ev.preventDefault();
      redo();
      return;
    }
    if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === "d"){
      ev.preventDefault();
      duplicateSelection();
      return;
    }
    if(ev.key === "Delete" || ev.key === "Backspace"){
      if(typing) return;
      ev.preventDefault();
      deleteSelection();
      return;
    }
    if(ev.key === "Escape"){
      // close help first if open
      if(helpModal.classList.contains("show")){
        closeHelp();
        return;
      }
      connectFrom = null;
      selectedLinkId = null;
      updateLinkSelectionUI();
    }
  });

  /* =========================
     Init
  ========================= */
  function initDefaults(){
    state.settings.gridOn = true;
    state.settings.snapOn = true;
    state.settings.safeOn = true;

    addElement("note", 70, 70);
    addElement("code", 420, 110);
  }

  const loaded = load();
  applySettingsToUI();
  resizeCanvas();

  if(!loaded){
    initDefaults();
  }

  history.undo.length = 0;
  history.redo.length = 0;
  history.undo.push(JSON.stringify(state));
  updateUndoRedoUI();

  setMode("select");
  rerenderAll();

  applySettingsToUI();

  document.addEventListener("visibilitychange", () => {
    if(!document.hidden) resizeCanvas();
  });

})();
</script>
</body>
</html>
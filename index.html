<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emoji Creator PRO ‚Äî Design ‚Ä¢ Layer ‚Ä¢ Export PNG</title>

  <!-- SEO -->
  <meta name="description" content="Top-quality emoji creator: pick emojis, add text and stickers, drag/resize/rotate, choose backgrounds, and export high-resolution PNG. Works offline after first load." />
  <meta name="keywords" content="emoji maker, emoji creator, sticker maker, png export, canvas editor, whatsapp sticker, thumbnail maker, programmers picnic, learn with champak" />
  <meta name="author" content="Champak Roy" />
  <meta name="robots" content="index,follow" />
  <meta name="theme-color" content="#f59e0b" />

  <style>
    :root{
      --bg:#fff7e6; --card:#ffffff; --ink:#1f2937; --muted:#6b7280;
      --brand:#d97706; --brand2:#f59e0b; --border:#eadcc5;
      --shadow:0 18px 40px rgba(31,41,55,.14);
      --shadow2:0 10px 24px rgba(31,41,55,.08);
      --r:18px;
      --grid:rgba(31,41,55,.06);
      --snap:rgba(245,158,11,.9);
      --danger:#ef4444;
      --ok:#10b981;
      --codebg:#0b1220; --codeink:#e5e7eb;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:
        radial-gradient(900px 520px at 10% -10%, rgba(245,158,11,.22), transparent 60%),
        radial-gradient(900px 520px at 90% 0%, rgba(217,119,6,.18), transparent 55%),
        var(--bg);
    }
    a{color:inherit}
    .topbar{
      position:sticky; top:0; z-index:50;
      backdrop-filter:saturate(1.2) blur(10px);
      background:rgba(255,247,230,.82);
      border-bottom:1px solid var(--border);
    }
    .wrap{max-width:1280px; margin:0 auto; padding:12px 16px;}
    .row{display:flex; gap:12px; align-items:center; justify-content:space-between;}
    .brand{display:flex; gap:10px; align-items:center;}
    .logo{
      width:44px; height:44px; border-radius:16px;
      background:linear-gradient(135deg,var(--brand),var(--brand2));
      box-shadow:0 14px 34px rgba(217,119,6,.28);
    }
    h1{margin:0; font-size:16px}
    .sub{margin:2px 0 0; color:var(--muted); font-size:12px}
    .actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .btn{
      border:1px solid var(--border);
      background:#fff;
      padding:9px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      cursor:pointer;
      box-shadow:var(--shadow2);
      user-select:none;
    }
    .btn.primary{
      border-color:rgba(245,158,11,.55);
      background:rgba(245,158,11,.16);
      color:#7c4a00;
    }
    .btn.danger{
      border-color:rgba(239,68,68,.45);
      background:rgba(239,68,68,.12);
      color:#7a1d1d;
    }
    .btn:active{transform:translateY(1px)}
    .pill{
      font-size:12px; padding:7px 10px;
      border:1px solid var(--border); background:#fff;
      border-radius:999px; color:var(--muted);
      box-shadow:var(--shadow2);
    }

    .layout{
      max-width:1280px;
      margin:0 auto;
      padding:16px;
      display:grid;
      grid-template-columns: 360px 1fr 300px;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 1150px){
      .layout{grid-template-columns: 1fr; }
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .cardhead{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      background:
        radial-gradient(700px 220px at 20% 0%, rgba(245,158,11,.16), transparent 60%),
        #fff;
    }
    .cardhead h2{margin:0; font-size:13px}
    .cardhead p{margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.45}
    .cardbody{padding:12px}

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
    .field{display:grid; gap:6px}
    label{font-size:12px; color:var(--muted); font-weight:800}
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      outline:none;
      font-size:13px;
      box-shadow:0 10px 22px rgba(31,41,55,.06);
    }
    textarea{min-height:70px; resize:vertical}
    input[type="color"]{
      width:100%;
      height:44px;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      padding:6px;
    }
    .small{font-size:12px; color:var(--muted); line-height:1.4}
    .hint{
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(217,119,6,.45);
      background:rgba(255,247,230,.6);
      color:#5c3b00;
      font-size:12px;
      line-height:1.55;
    }

    /* Canvas */
    .stage{
      position:relative;
      background:
        linear-gradient(0deg, transparent 0 23px, var(--grid) 23px 24px),
        linear-gradient(90deg, transparent 0 23px, var(--grid) 23px 24px);
      background-size:24px 24px;
      border-radius:var(--r);
      border:1px solid var(--border);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .stageTop{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.75);
      backdrop-filter: blur(8px);
    }
    .stageTop .left, .stageTop .right{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .chip{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      font-size:12px;
      color:var(--muted);
      box-shadow:0 10px 22px rgba(31,41,55,.06);
    }
    canvas{display:block; width:100%; height:auto; background:transparent}
    .stageInner{padding:12px}
    .stageWrap{display:grid; gap:10px}
    .stageFooter{
      padding:10px 12px;
      border-top:1px solid var(--border);
      background:#fff;
      color:var(--muted);
      font-size:12px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }

    /* Layer list */
    .layers{display:grid; gap:10px}
    .layerItem{
      border:1px solid var(--border);
      border-radius:16px;
      background:#fff;
      padding:10px;
      box-shadow:0 10px 22px rgba(31,41,55,.06);
      display:grid;
      gap:8px;
    }
    .layerTop{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      font-size:12px;
    }
    .layerName{
      font-weight:900;
      max-width: 210px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .layerBtns{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end}
    .mini{
      padding:6px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      font-size:12px;
      font-weight:900;
    }
    .mini.active{
      border-color:rgba(245,158,11,.6);
      background:rgba(245,158,11,.14);
      color:#7c4a00;
    }
    .mini.danger{
      border-color:rgba(239,68,68,.45);
      background:rgba(239,68,68,.10);
      color:#7a1d1d;
    }
    .controlsRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .sliderWrap{display:grid; gap:6px}
    input[type="range"]{width:100%}

    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--ink);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background:#fff;
      border:1px solid var(--border);
      border-radius:999px;
      padding:10px 12px;
      box-shadow:0 18px 40px rgba(31,41,55,.18);
      font-size:12px;
      font-weight:800;
      display:none;
      z-index:99;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1>Emoji Creator PRO</h1>
            <div class="sub">Pick emojis ‚Ä¢ Add text/stickers ‚Ä¢ Drag/resize/rotate ‚Ä¢ Export PNG ‚Ä¢ Copy</div>
          </div>
        </div>
        <div class="actions">
          <button class="btn" id="btnNew">New</button>
          <button class="btn" id="btnSave">Save</button>
          <button class="btn" id="btnLoad">Load</button>
          <button class="btn primary" id="btnExport">Export PNG</button>
          <button class="btn primary" id="btnCopy">Copy PNG</button>
        </div>
      </div>
    </div>
  </div>

  <div class="layout">
    <!-- LEFT: Tools -->
    <section class="card">
      <div class="cardhead">
        <h2>Tools</h2>
        <p>Create an emoji sticker / thumbnail. Everything is layer-based. Select a layer to edit.</p>
      </div>
      <div class="cardbody">
        <div class="hint" style="margin-bottom:12px">
          <b>Quick controls</b><br>
          Drag to move ‚Ä¢ Mouse wheel to scale (on canvas) ‚Ä¢ Hold <span class="kbd">Shift</span> + wheel to rotate ‚Ä¢
          Nudge with <span class="kbd">‚Üë</span><span class="kbd">‚Üì</span><span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> ‚Ä¢ Delete with <span class="kbd">Del</span>.
        </div>

        <div class="grid2">
          <div class="field">
            <label>Canvas size</label>
            <select id="sizePreset">
              <option value="512">Sticker 512√ó512</option>
              <option value="768">Square 768√ó768</option>
              <option value="1080" selected>Square 1080√ó1080</option>
              <option value="1200">Square 1200√ó1200</option>
              <option value="1920x1080">YouTube 1920√ó1080</option>
              <option value="1080x1920">Story 1080√ó1920</option>
            </select>
          </div>
          <div class="field">
            <label>Background</label>
            <select id="bgMode">
              <option value="transparent">Transparent</option>
              <option value="solid" selected>Solid color</option>
              <option value="gradient">Gradient</option>
            </select>
          </div>
        </div>

        <div class="grid2" style="margin-top:10px">
          <div class="field" id="bgColorWrap">
            <label>BG color</label>
            <input type="color" id="bgColor" value="#ffffff">
          </div>
          <div class="field" id="bgColor2Wrap" style="display:none">
            <label>BG color 2</label>
            <input type="color" id="bgColor2" value="#fff7e6">
          </div>
        </div>

        <div class="grid2" style="margin-top:10px">
          <button class="btn primary" id="addEmoji">+ Add Emoji</button>
          <button class="btn primary" id="addText">+ Add Text</button>
          <button class="btn" id="addShape">+ Add Shape</button>
          <button class="btn" id="addImage">+ Add Image</button>
        </div>

        <div class="field" style="margin-top:12px">
          <label>Emoji picker</label>
          <div class="grid3" id="emojiGrid" aria-label="Emoji picker"></div>
          <div class="small" style="margin-top:6px">Tip: Click an emoji to insert it as a new layer.</div>
        </div>

        <div class="field" style="margin-top:12px">
          <label>Project title (optional)</label>
          <input id="projectTitle" type="text" placeholder="e.g., Happy Sankranti sticker" />
        </div>

        <div class="hint" style="margin-top:12px">
          <b>Export tips</b><br>
          ‚Ä¢ Use 1080√ó1080 for best quality.<br>
          ‚Ä¢ Transparent background is best for stickers.<br>
          ‚Ä¢ After exporting PNG, you can share on WhatsApp / Instagram.
        </div>

        <input id="fileInput" type="file" accept="image/*" style="display:none" />
      </div>
    </section>

    <!-- CENTER: Canvas -->
    <section class="stageWrap">
      <div class="stage">
        <div class="stageTop">
          <div class="left">
            <span class="chip" id="chipSize">1080√ó1080</span>
            <span class="chip" id="chipLayer">No layer selected</span>
          </div>
          <div class="right">
            <button class="btn" id="btnFit">Fit</button>
            <button class="btn" id="btnCenter">Center</button>
            <button class="btn danger" id="btnDelete">Delete Layer</button>
          </div>
        </div>
        <div class="stageInner">
          <canvas id="c" width="1080" height="1080" aria-label="Emoji canvas"></canvas>
        </div>
        <div class="stageFooter">
          <span>Made for <b>Programmer‚Äôs Picnic</b> ‚Ä¢ Works offline after first load</span>
          <span>Selected: <span class="kbd" id="selMeta">‚Äî</span></span>
        </div>
      </div>
    </section>

    <!-- RIGHT: Layers -->
    <section class="card">
      <div class="cardhead">
        <h2>Layers</h2>
        <p>Reorder, lock, hide, and fine-tune position/size/rotation.</p>
      </div>
      <div class="cardbody">
        <div class="layers" id="layers"></div>

        <div style="height:10px"></div>
        <div class="hint">
          <b>Precision</b><br>
          ‚Ä¢ Use the sliders in the selected layer card.<br>
          ‚Ä¢ For tiny moves, use arrow keys.<br>
          ‚Ä¢ Lock layers to avoid accidental drag.
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const EMOJIS = [
    "üòÄ","üòÑ","üòÅ","üòÇ","ü§£","ü•≥","üòé","üòç","üòò","ü§©","üòá","ü§ó","ü§î","üò¥","ü§Ø","ü•∂","ü•µ",
    "üëç","üëè","üôè","üí™","üî•","‚ú®","üíØ","üéâ","üéä","üéÅ","üèÜ","üéØ","üß†","üí°","üìå","‚úÖ","‚ùå",
    "‚ù§Ô∏è","üß°","üíõ","üíö","üíô","üíú","ü§ç","üñ§","ü§é",
    "üå∏","üåº","üåª","üå∫","üåø","üçÄ","üåà","‚òÄÔ∏è","üåô","‚≠ê","‚ö°",
    "üéµ","üé∂","üé§","üéß","üì∏","üé¨","üñºÔ∏è","üßæ","üìö",
    "üöÄ","üõ∏","üß≠","üó∫Ô∏è","üè†","üè´","üßë‚Äçüíª","üë©‚Äçüè´","üë®‚Äçüéì",
    "üêØ","ü¶Å","üêº","üê∂","üê±","ü¶ä","üêµ","ü¶Ñ",
    "üçï","üçî","üçü","üçø","üç©","üç´","‚òï","üçµ"
  ];

  const $ = sel => document.querySelector(sel);
  const el = (tag, attrs={}) => Object.assign(document.createElement(tag), attrs);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const uuid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  const toast = (msg) => {
    const t = $("#toast");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(t._tt);
    t._tt = setTimeout(()=> t.style.display="none", 1400);
  };

  const canvas = $("#c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  let W = canvas.width, H = canvas.height;
  let bgMode = "solid";
  let bgColor = "#ffffff";
  let bgColor2 = "#fff7e6";

  let layers = [];
  let selectedId = null;
  let dragging = false;
  let dragOffset = {x:0,y:0};
  let pointerDown = false;

  const layersEl = $("#layers");
  const chipSize = $("#chipSize");
  const chipLayer = $("#chipLayer");
  const selMeta = $("#selMeta");

  function drawBackground(){
    if (bgMode === "transparent"){ ctx.clearRect(0,0,W,H); return; }
    if (bgMode === "solid"){ ctx.fillStyle = bgColor; ctx.fillRect(0,0,W,H); return; }
    const g = ctx.createLinearGradient(0,0,W,H);
    g.addColorStop(0, bgColor);
    g.addColorStop(1, bgColor2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function getLayerBounds(layer){
    if (layer.type === "emoji"){
      const s = (layer.fontSize ?? 160) * 0.95;
      return {x:-s/2, y:-s/2, w:s, h:s};
    }
    if (layer.type === "text"){
      const size = layer.fontSize ?? 90;
      const txt = layer.text ?? "Text";
      const w = Math.max(120, txt.length * size * 0.58);
      const h = size * 1.2;
      return {x:-w/2, y:-h/2, w, h};
    }
    if (layer.type === "shape"){
      const w = layer.w ?? 420;
      const h = layer.h ?? 260;
      return {x:-w/2, y:-h/2, w, h};
    }
    if (layer.type === "image"){
      const w = layer.w ?? (layer.img ? layer.img.naturalWidth : 300);
      const h = layer.h ?? (layer.img ? layer.img.naturalHeight : 300);
      return {x:-w/2, y:-h/2, w, h};
    }
    return {x:-100, y:-100, w:200, h:200};
  }

  function render(){
    drawBackground();

    for (const layer of layers){
      if (layer.hidden) continue;

      ctx.save();
      ctx.globalAlpha = clamp(layer.opacity ?? 1, 0, 1);
      ctx.translate(layer.x, layer.y);
      ctx.rotate(layer.rotation);
      ctx.scale(layer.scale, layer.scale);

      if (layer.type === "emoji"){
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const size = layer.fontSize ?? 160;
        ctx.font = `${size}px ${layer.font ?? "Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, EmojiOne Color, sans-serif"}`;
        ctx.fillText(layer.emoji ?? "üòÄ", 0, 0);
      }

      if (layer.type === "text"){
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const size = layer.fontSize ?? 90;
        ctx.font = `900 ${size}px ${layer.font ?? "system-ui, Segoe UI, Arial"}`;
        const txt = layer.text ?? "Hello!";
        const sw = layer.strokeWidth ?? 0;
        if (sw > 0){
          ctx.lineWidth = sw;
          ctx.strokeStyle = layer.stroke ?? "#111827";
          ctx.strokeText(txt, 0, 0);
        }
        ctx.fillStyle = layer.fill ?? "#111827";
        ctx.fillText(txt, 0, 0);
      }

      if (layer.type === "shape"){
        const fill = layer.fill ?? "#f59e0b";
        const stroke = layer.stroke ?? "rgba(31,41,55,.35)";
        const sw = layer.strokeWidth ?? 4;
        const w = layer.w ?? 420;
        const h = layer.h ?? 260;

        ctx.beginPath();
        if (layer.shape === "circle"){
          const r = Math.min(w,h)/2;
          ctx.arc(0,0,r,0,Math.PI*2);
        } else if (layer.shape === "star"){
          const spikes = 5;
          const outer = Math.min(w,h)/2;
          const inner = outer * 0.45;
          let rot = Math.PI / 2 * 3;
          ctx.moveTo(0, -outer);
          for (let i=0; i<spikes; i++){
            ctx.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer);
            rot += Math.PI / spikes;
            ctx.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner);
            rot += Math.PI / spikes;
          }
          ctx.closePath();
        } else if (layer.shape === "blob"){
          const r = Math.min(w,h)/2;
          const steps = 14;
          for (let i=0;i<=steps;i++){
            const a = (i/steps)*Math.PI*2;
            const jitter = 0.18 + 0.12*Math.sin(i*1.9);
            const rr = r*(1 + jitter*Math.sin(i*2.3));
            const px = Math.cos(a)*rr;
            const py = Math.sin(a)*rr*0.82;
            if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.closePath();
        } else {
          const rx = w/2, ry = h/2;
          const rad = Math.min(38, Math.min(rx,ry));
          roundRect(ctx, -rx, -ry, w, h, rad);
        }

        ctx.fillStyle = fill;
        ctx.fill();
        if (sw > 0){
          ctx.lineWidth = sw;
          ctx.strokeStyle = stroke;
          ctx.stroke();
        }
      }

      if (layer.type === "image" && layer.img){
        const img = layer.img;
        const iw = layer.w ?? img.naturalWidth;
        const ih = layer.h ?? img.naturalHeight;
        ctx.drawImage(img, -iw/2, -ih/2, iw, ih);
      }

      if (layer.id === selectedId){
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.setLineDash([10,8]);
        ctx.lineWidth = 3 / layer.scale;
        ctx.strokeStyle = "rgba(245,158,11,.95)";
        const bb = getLayerBounds(layer);
        ctx.strokeRect(bb.x, bb.y, bb.w, bb.h);
        ctx.restore();
      }

      ctx.restore();
    }

    updateMeta();
    requestAnimationFrame(render);
  }

  function screenToCanvas(px, py){
    const rect = canvas.getBoundingClientRect();
    const sx = (px - rect.left) / rect.width * W;
    const sy = (py - rect.top) / rect.height * H;
    return {x:sx, y:sy};
  }

  function hitTest(point){
    for (let i = layers.length - 1; i >= 0; i--){
      const layer = layers[i];
      if (layer.hidden || layer.locked) continue;

      const dx = point.x - layer.x;
      const dy = point.y - layer.y;

      const cos = Math.cos(-layer.rotation);
      const sin = Math.sin(-layer.rotation);
      const rx = (dx * cos - dy * sin) / layer.scale;
      const ry = (dx * sin + dy * cos) / layer.scale;

      const bb = getLayerBounds(layer);
      if (rx >= bb.x && rx <= bb.x + bb.w && ry >= bb.y && ry <= bb.y + bb.h){
        return layer.id;
      }
    }
    return null;
  }

  function select(id){
    selectedId = id;
    const layer = layers.find(l => l.id === id) || null;
    chipLayer.textContent = layer ? `Selected: ${layer.name}` : "No layer selected";
    rebuildLayersUI();
  }

  function addLayer(layer){
    layers.push(layer);
    select(layer.id);
    toast("Layer added");
  }

  function removeSelected(){
    if (!selectedId) return;
    const idx = layers.findIndex(l => l.id === selectedId);
    if (idx >= 0){
      const name = layers[idx].name;
      layers.splice(idx, 1);
      selectedId = null;
      toast(`Deleted: ${name}`);
      rebuildLayersUI();
    }
  }

  function moveLayer(id, dir){
    const i = layers.findIndex(l => l.id === id);
    if (i < 0) return;
    const j = clamp(i + dir, 0, layers.length - 1);
    if (i === j) return;
    const [item] = layers.splice(i, 1);
    layers.splice(j, 0, item);
    rebuildLayersUI();
  }

  function duplicateLayer(id){
    const layer = layers.find(l => l.id === id);
    if (!layer) return;
    const copy = JSON.parse(JSON.stringify({...layer, img: undefined}));
    copy.id = uuid();
    copy.name = layer.name + " (copy)";
    copy.x += 40; copy.y += 40;

    if (layer.type === "image" && layer.imgSrc){
      const img = new Image();
      img.src = layer.imgSrc;
      copy.img = img;
    }

    layers.push(copy);
    select(copy.id);
    toast("Duplicated");
  }

  function rebuildLayersUI(){
    layersEl.innerHTML = "";
    for (let i = layers.length - 1; i >= 0; i--){
      const layer = layers[i];
      const isSel = layer.id === selectedId;

      const wrap = el("div", {className:"layerItem"});
      const top = el("div", {className:"layerTop"});
      const name = el("div", {className:"layerName", textContent: layer.name});
      const btns = el("div", {className:"layerBtns"});

      const bSel = el("button", {className:"mini" + (isSel ? " active":""), textContent: isSel ? "Selected" : "Select"});
      bSel.onclick = () => select(layer.id);

      const bUp = el("button", {className:"mini", textContent:"Up"});
      bUp.onclick = () => moveLayer(layer.id, +1);

      const bDown = el("button", {className:"mini", textContent:"Down"});
      bDown.onclick = () => moveLayer(layer.id, -1);

      const bDup = el("button", {className:"mini", textContent:"Dup"});
      bDup.onclick = () => duplicateLayer(layer.id);

      const bHide = el("button", {className:"mini" + (layer.hidden ? " active":""), textContent: layer.hidden ? "Hidden":"Hide"});
      bHide.onclick = () => { layer.hidden = !layer.hidden; rebuildLayersUI(); };

      const bLock = el("button", {className:"mini" + (layer.locked ? " active":""), textContent: layer.locked ? "Locked":"Lock"});
      bLock.onclick = () => { layer.locked = !layer.locked; rebuildLayersUI(); };

      const bDel = el("button", {className:"mini danger", textContent:"Del"});
      bDel.onclick = () => {
        if (layer.id === selectedId) removeSelected();
        else { layers = layers.filter(l=>l.id!==layer.id); rebuildLayersUI(); }
      };

      [bSel,bUp,bDown,bDup,bHide,bLock,bDel].forEach(b => btns.appendChild(b));
      top.appendChild(name);
      top.appendChild(btns);
      wrap.appendChild(top);

      if (isSel) wrap.appendChild(buildControls(layer));
      layersEl.appendChild(wrap);
    }
  }

  function buildControls(layer){
    const box = el("div", {className:"controls"});

    const nameField = el("div", {className:"field"});
    nameField.appendChild(el("label", {textContent:"Layer name"}));
    const nameIn = el("input", {type:"text", value: layer.name});
    nameIn.oninput = () => { layer.name = nameIn.value || layer.name; chipLayer.textContent = `Selected: ${layer.name}`; };
    nameField.appendChild(nameIn);
    box.appendChild(nameField);

    if (layer.type === "emoji"){
      const f = el("div",{className:"field"});
      f.appendChild(el("label",{textContent:"Emoji"}));
      const inEmoji = el("input",{type:"text", value: layer.emoji ?? "üòÄ"});
      inEmoji.oninput = () => layer.emoji = inEmoji.value.slice(0,4);
      f.appendChild(inEmoji);
      box.appendChild(f);
    }

    if (layer.type === "text"){
      const f = el("div",{className:"field"});
      f.appendChild(el("label",{textContent:"Text"}));
      const ta = el("textarea",{value: layer.text ?? "Hello!"});
      ta.oninput = () => layer.text = ta.value;
      f.appendChild(ta);
      box.appendChild(f);

      const row = el("div",{className:"controlsRow"});
      const fill = el("div",{className:"field"});
      fill.appendChild(el("label",{textContent:"Fill"}));
      const c1 = el("input",{type:"color", value: (layer.fill ?? "#111827")});
      c1.oninput = () => layer.fill = c1.value;
      fill.appendChild(c1);
      row.appendChild(fill);

      const stroke = el("div",{className:"field"});
      stroke.appendChild(el("label",{textContent:"Stroke"}));
      const c2 = el("input",{type:"color", value: (layer.stroke ?? "#111827")});
      c2.oninput = () => layer.stroke = c2.value;
      stroke.appendChild(c2);
      row.appendChild(stroke);

      box.appendChild(row);
    }

    if (layer.type === "shape"){
      const row = el("div",{className:"controlsRow"});

      const shape = el("div",{className:"field"});
      shape.appendChild(el("label",{textContent:"Shape"}));
      const sel = el("select");
      ["rect","circle","blob","star"].forEach(v => sel.appendChild(el("option",{value:v, textContent:v})));
      sel.value = layer.shape ?? "rect";
      sel.onchange = () => layer.shape = sel.value;
      shape.appendChild(sel);
      row.appendChild(shape);

      const fill = el("div",{className:"field"});
      fill.appendChild(el("label",{textContent:"Fill"}));
      const c = el("input",{type:"color", value:(layer.fill ?? "#f59e0b")});
      c.oninput = () => layer.fill = c.value;
      fill.appendChild(c);
      row.appendChild(fill);

      box.appendChild(row);

      const row2 = el("div",{className:"controlsRow"});
      const w = el("div",{className:"field"});
      w.appendChild(el("label",{textContent:"Width"}));
      const wi = el("input",{type:"number", value: layer.w ?? 420, min:20, max:5000});
      wi.oninput = () => layer.w = clamp(+wi.value || 420, 20, 5000);
      w.appendChild(wi);
      row2.appendChild(w);

      const h = el("div",{className:"field"});
      h.appendChild(el("label",{textContent:"Height"}));
      const hi = el("input",{type:"number", value: layer.h ?? 260, min:20, max:5000});
      hi.oninput = () => layer.h = clamp(+hi.value || 260, 20, 5000);
      h.appendChild(hi);
      row2.appendChild(h);

      box.appendChild(row2);
    }

    if (layer.type === "image"){
      const row = el("div",{className:"controlsRow"});
      const w = el("div",{className:"field"});
      w.appendChild(el("label",{textContent:"Width"}));
      const wi = el("input",{type:"number", value: layer.w ?? 600, min:10, max:8000});
      wi.oninput = () => layer.w = clamp(+wi.value || 600, 10, 8000);
      w.appendChild(wi);
      row.appendChild(w);

      const h = el("div",{className:"field"});
      h.appendChild(el("label",{textContent:"Height"}));
      const hi = el("input",{type:"number", value: layer.h ?? 600, min:10, max:8000});
      hi.oninput = () => layer.h = clamp(+hi.value || 600, 10, 8000);
      h.appendChild(hi);
      row.appendChild(h);
      box.appendChild(row);
    }

    const sliders = el("div",{className:"sliderWrap", style:"margin-top:8px"});
    sliders.appendChild(el("label",{textContent:"Scale"}));
    const s = el("input",{type:"range", min:"0.1", max:"5", step:"0.01", value: layer.scale});
    s.oninput = () => layer.scale = +s.value;
    sliders.appendChild(s);
    box.appendChild(sliders);

    const rot = el("div",{className:"sliderWrap"});
    rot.appendChild(el("label",{textContent:"Rotation"}));
    const r = el("input",{type:"range", min:"-3.1416", max:"3.1416", step:"0.0005", value: layer.rotation});
    r.oninput = () => layer.rotation = +r.value;
    rot.appendChild(r);
    box.appendChild(rot);

    const op = el("div",{className:"sliderWrap"});
    op.appendChild(el("label",{textContent:"Opacity"}));
    const o = el("input",{type:"range", min:"0", max:"1", step:"0.01", value: layer.opacity ?? 1});
    o.oninput = () => layer.opacity = +o.value;
    op.appendChild(o);
    box.appendChild(op);

    const pos = el("div",{className:"controlsRow"});
    const fx = el("div",{className:"field"});
    fx.appendChild(el("label",{textContent:"X"}));
    const inx = el("input",{type:"number", value: Math.round(layer.x), min:-99999, max:99999});
    inx.oninput = () => layer.x = +inx.value || layer.x;
    fx.appendChild(inx);
    pos.appendChild(fx);

    const fy = el("div",{className:"field"});
    fy.appendChild(el("label",{textContent:"Y"}));
    const iny = el("input",{type:"number", value: Math.round(layer.y), min:-99999, max:99999});
    iny.oninput = () => layer.y = +iny.value || layer.y;
    fy.appendChild(iny);
    pos.appendChild(fy);

    box.appendChild(pos);
    return box;
  }

  function updateMeta(){
    chipSize.textContent = `${W}√ó${H}`;
    const sel = layers.find(l => l.id === selectedId) || null;
    selMeta.textContent = sel ? `${sel.type} ‚Ä¢ x:${Math.round(sel.x)} y:${Math.round(sel.y)} ‚Ä¢ s:${sel.scale.toFixed(2)} ‚Ä¢ r:${(sel.rotation).toFixed(2)}` : "‚Äî";
  }

  function buildEmojiPicker(){
    const grid = $("#emojiGrid");
    grid.innerHTML = "";
    EMOJIS.slice(0, 48).forEach(e => {
      const b = el("button", {className:"btn", textContent: e});
      b.style.padding = "10px 0";
      b.style.borderRadius = "14px";
      b.onclick = () => addEmojiLayer(e);
      grid.appendChild(b);
    });
  }

  function centerPos(){ return {x: W/2, y: H/2}; }

  function addEmojiLayer(emoji="üòÄ"){
    const {x,y} = centerPos();
    addLayer({
      id: uuid(),
      type:"emoji",
      name:`Emoji ${emoji}`,
      hidden:false, locked:false,
      x, y, scale:1, rotation:0, opacity:1,
      emoji, fontSize: 240
    });
  }
  function addTextLayer(){
    const {x,y} = centerPos();
    addLayer({
      id: uuid(),
      type:"text",
      name:"Text",
      hidden:false, locked:false,
      x, y, scale:1, rotation:0, opacity:1,
      text:"Hello!",
      fontSize: 120,
      fill:"#111827",
      stroke:"#ffffff",
      strokeWidth: 10
    });
  }
  function addShapeLayer(){
    const {x,y} = centerPos();
    addLayer({
      id: uuid(),
      type:"shape",
      name:"Shape",
      hidden:false, locked:false,
      x, y, scale:1, rotation:0, opacity:1,
      shape:"rect", w: 720, h: 420,
      fill:"#f59e0b",
      stroke:"rgba(31,41,55,.35)",
      strokeWidth: 6
    });
  }

  function fileToDataURL(file){
    return new Promise((resolve,reject)=>{
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

  async function addImageLayerFromFile(file){
    const url = await fileToDataURL(file);
    const img = new Image();
    img.onload = () => {
      const {x,y} = centerPos();
      const maxSide = Math.max(img.naturalWidth, img.naturalHeight);
      const target = Math.min(Math.min(W,H)*0.75, 900);
      const scale = target / maxSide;
      addLayer({
        id: uuid(),
        type:"image",
        name:`Image ${file.name}`,
        hidden:false, locked:false,
        x, y, scale:1, rotation:0, opacity:1,
        img, imgSrc:url,
        w: Math.round(img.naturalWidth*scale),
        h: Math.round(img.naturalHeight*scale)
      });
    };
    img.src = url;
  }

  canvas.addEventListener("pointerdown", (e) => {
    pointerDown = true;
    canvas.setPointerCapture(e.pointerId);
    const p = screenToCanvas(e.clientX, e.clientY);
    const hit = hitTest(p);
    if (hit){
      select(hit);
      const layer = layers.find(l=>l.id===hit);
      if (!layer || layer.locked) return;
      dragging = true;
      dragOffset.x = p.x - layer.x;
      dragOffset.y = p.y - layer.y;
    } else select(null);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!pointerDown || !dragging || !selectedId) return;
    const layer = layers.find(l=>l.id===selectedId);
    if (!layer || layer.locked) return;
    const p = screenToCanvas(e.clientX, e.clientY);
    layer.x = p.x - dragOffset.x;
    layer.y = p.y - dragOffset.y;
  });

  canvas.addEventListener("pointerup", (e) => {
    pointerDown = false;
    dragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  canvas.addEventListener("wheel", (e) => {
    if (!selectedId) return;
    const layer = layers.find(l=>l.id===selectedId);
    if (!layer || layer.locked) return;
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    if (e.shiftKey){
      layer.rotation = clamp(layer.rotation + delta*0.06, -Math.PI, Math.PI);
    } else {
      const s = layer.scale * (delta > 0 ? 0.95 : 1.05);
      layer.scale = clamp(s, 0.08, 7);
    }
  }, {passive:false});

  window.addEventListener("keydown", (e) => {
    const sel = layers.find(l=>l.id===selectedId);
    if (!sel) return;
    const t = e.target;
    if (t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.tagName === "SELECT")) return;

    const step = e.shiftKey ? 20 : 5;
    if (e.key === "ArrowLeft")  { sel.x -= step; e.preventDefault(); }
    if (e.key === "ArrowRight") { sel.x += step; e.preventDefault(); }
    if (e.key === "ArrowUp")    { sel.y -= step; e.preventDefault(); }
    if (e.key === "ArrowDown")  { sel.y += step; e.preventDefault(); }
    if (e.key === "Delete")     { removeSelected(); e.preventDefault(); }
  });

  $("#addEmoji").onclick = () => addEmojiLayer("üòÄ");
  $("#addText").onclick = () => addTextLayer();
  $("#addShape").onclick = () => addShapeLayer();

  $("#addImage").onclick = () => $("#fileInput").click();
  $("#fileInput").addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) await addImageLayerFromFile(file);
    e.target.value = "";
  });

  buildEmojiPicker();

  $("#bgMode").addEventListener("change", (e) => {
    bgMode = e.target.value;
    $("#bgColorWrap").style.display = (bgMode === "solid" || bgMode === "gradient") ? "block" : "none";
    $("#bgColor2Wrap").style.display = (bgMode === "gradient") ? "block" : "none";
  });
  $("#bgColor").addEventListener("input", (e) => bgColor = e.target.value);
  $("#bgColor2").addEventListener("input", (e) => bgColor2 = e.target.value);

  $("#sizePreset").addEventListener("change", (e) => {
    const v = e.target.value;
    let w,h;
    if (v.includes("x")){ [w,h] = v.split("x").map(Number); }
    else { w = Number(v); h = Number(v); }
    W = w; H = h;
    canvas.width = w; canvas.height = h;
    toast("Canvas resized");
  });

  $("#btnCenter").onclick = () => {
    const sel = layers.find(l=>l.id===selectedId);
    if (!sel) return;
    sel.x = W/2; sel.y = H/2;
    toast("Centered");
  };
  $("#btnFit").onclick = () => toast("Fit is automatic");
  $("#btnDelete").onclick = () => removeSelected();

  // Save/Load
  const LS_KEY = "pp_emoji_creator_projects_v1";
  const getStore = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); } catch { return []; } };
  const setStore = (arr) => localStorage.setItem(LS_KEY, JSON.stringify(arr));

  $("#btnNew").onclick = () => {
    if (!confirm("Start a new design? (This will clear current layers)")) return;
    layers = []; selectedId = null; rebuildLayersUI(); toast("New canvas");
  };

  $("#btnSave").onclick = () => {
    const title = ($("#projectTitle").value || "").trim() || `Emoji Project ${new Date().toLocaleString()}`;
    const proj = { title, W, H, bgMode, bgColor, bgColor2, layers: layers.map(l => ({...l, img: undefined})) };
    const store = getStore();
    const i = store.findIndex(p => p.title === title);
    if (i >= 0) store[i] = proj; else store.unshift(proj);
    setStore(store.slice(0, 20));
    toast("Saved");
  };

  $("#btnLoad").onclick = () => {
    const store = getStore();
    if (!store.length){ toast("No saved projects"); return; }
    const titles = store.map((p,i)=> `${i+1}) ${p.title}`).join("\n");
    const pick = prompt("Enter project number to load:\n\n" + titles, "1");
    const n = Number(pick);
    if (!n || n < 1 || n > store.length) return;
    const proj = store[n-1];

    $("#projectTitle").value = proj.title || "";
    W = proj.W || 1080; H = proj.H || 1080;
    canvas.width = W; canvas.height = H;

    bgMode = proj.bgMode || "solid";
    bgColor = proj.bgColor || "#ffffff";
    bgColor2 = proj.bgColor2 || "#fff7e6";
    $("#bgMode").value = bgMode;
    $("#bgColor").value = bgColor;
    $("#bgColor2").value = bgColor2;
    $("#bgColorWrap").style.display = (bgMode === "solid" || bgMode === "gradient") ? "block" : "none";
    $("#bgColor2Wrap").style.display = (bgMode === "gradient") ? "block" : "none";

    layers = (proj.layers || []).map(l => {
      if (l.type === "image" && l.imgSrc){
        const img = new Image(); img.src = l.imgSrc;
        return {...l, img};
      }
      return l;
    });
    selectedId = layers.length ? layers[layers.length-1].id : null;
    rebuildLayersUI();
    toast("Loaded");
  };

  async function exportPNGBlob(){
    const off = document.createElement("canvas");
    off.width = W; off.height = H;
    const ox = off.getContext("2d");

    if (bgMode === "transparent") ox.clearRect(0,0,W,H);
    else if (bgMode === "solid"){ ox.fillStyle = bgColor; ox.fillRect(0,0,W,H); }
    else {
      const g = ox.createLinearGradient(0,0,W,H);
      g.addColorStop(0,bgColor); g.addColorStop(1,bgColor2);
      ox.fillStyle = g; ox.fillRect(0,0,W,H);
    }

    for (const layer of layers){
      if (layer.hidden) continue;
      ox.save();
      ox.globalAlpha = clamp(layer.opacity ?? 1, 0, 1);
      ox.translate(layer.x, layer.y);
      ox.rotate(layer.rotation);
      ox.scale(layer.scale, layer.scale);

      if (layer.type === "emoji"){
        ox.textAlign="center"; ox.textBaseline="middle";
        const size = layer.fontSize ?? 160;
        ox.font = `${size}px ${layer.font ?? "Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif"}`;
        ox.fillText(layer.emoji ?? "üòÄ", 0, 0);
      }
      if (layer.type === "text"){
        ox.textAlign="center"; ox.textBaseline="middle";
        const size = layer.fontSize ?? 90;
        ox.font = `900 ${size}px ${layer.font ?? "system-ui, Segoe UI, Arial"}`;
        const txt = layer.text ?? "Hello!";
        const sw = layer.strokeWidth ?? 0;
        if (sw > 0){ ox.lineWidth = sw; ox.strokeStyle = layer.stroke ?? "#111827"; ox.strokeText(txt, 0, 0); }
        ox.fillStyle = layer.fill ?? "#111827";
        ox.fillText(txt, 0, 0);
      }
      if (layer.type === "shape"){
        const fill = layer.fill ?? "#f59e0b";
        const stroke = layer.stroke ?? "rgba(31,41,55,.35)";
        const sw = layer.strokeWidth ?? 4;
        const w = layer.w ?? 420;
        const h = layer.h ?? 260;

        ox.beginPath();
        if (layer.shape === "circle") ox.arc(0,0,Math.min(w,h)/2,0,Math.PI*2);
        else if (layer.shape === "star"){
          const spikes=5, outer=Math.min(w,h)/2, inner=outer*0.45;
          let rot=Math.PI/2*3;
          ox.moveTo(0,-outer);
          for (let i=0;i<spikes;i++){
            ox.lineTo(Math.cos(rot)*outer, Math.sin(rot)*outer); rot += Math.PI/spikes;
            ox.lineTo(Math.cos(rot)*inner, Math.sin(rot)*inner); rot += Math.PI/spikes;
          }
          ox.closePath();
        } else if (layer.shape === "blob"){
          const r = Math.min(w,h)/2, steps=14;
          for (let i=0;i<=steps;i++){
            const a=(i/steps)*Math.PI*2;
            const jitter=0.18+0.12*Math.sin(i*1.9);
            const rr=r*(1 + jitter*Math.sin(i*2.3));
            const px=Math.cos(a)*rr, py=Math.sin(a)*rr*0.82;
            if (i===0) ox.moveTo(px,py); else ox.lineTo(px,py);
          }
          ox.closePath();
        } else {
          const rx=w/2, ry=h/2, rad=Math.min(38,Math.min(rx,ry));
          const x=-rx, y=-ry;
          ox.beginPath();
          ox.moveTo(x+rad, y);
          ox.arcTo(x+w, y, x+w, y+h, rad);
          ox.arcTo(x+w, y+h, x, y+h, rad);
          ox.arcTo(x, y+h, x, y, rad);
          ox.arcTo(x, y, x+w, y, rad);
          ox.closePath();
        }

        ox.fillStyle=fill; ox.fill();
        if (sw>0){ ox.lineWidth=sw; ox.strokeStyle=stroke; ox.stroke(); }
      }
      if (layer.type === "image" && layer.img){
        const img = layer.img;
        const iw = layer.w ?? img.naturalWidth;
        const ih = layer.h ?? img.naturalHeight;
        ox.drawImage(img, -iw/2, -ih/2, iw, ih);
      }
      ox.restore();
    }

    return await new Promise(resolve => off.toBlob(resolve, "image/png"));
  }

  function downloadBlob(blob, filename){
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 500);
  }

  $("#btnExport").onclick = async () => {
    const blob = await exportPNGBlob();
    const title = ($("#projectTitle").value || "emoji").trim().replace(/[^\w\-]+/g,"_");
    downloadBlob(blob, `${title || "emoji"}_${W}x${H}.png`);
    toast("PNG downloaded");
  };

  $("#btnCopy").onclick = async () => {
    try{
      const blob = await exportPNGBlob();
      await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]);
      toast("Copied PNG to clipboard");
    }catch(err){
      console.warn(err);
      toast("Copy failed (try Export PNG)");
    }
  };

  // Default design
  function initDefault(){
    layers = [];
    addShapeLayer();
    const shape = layers[layers.length-1];
    shape.fill = "#fff7e6";
    shape.stroke = "rgba(245,158,11,.55)";
    shape.strokeWidth = 10;
    shape.w = 860;
    shape.h = 560;

    addEmojiLayer("ü•≥");
    const em = layers[layers.length-1];
    em.fontSize = 320;
    em.y = H/2 - 80;

    addTextLayer();
    const tx = layers[layers.length-1];
    tx.text = "HAPPY DAY!";
    tx.fontSize = 120;
    tx.stroke = "#ffffff";
    tx.strokeWidth = 14;
    tx.fill = "#111827";
    tx.y = H/2 + 210;

    selectedId = tx.id;
    rebuildLayersUI();
  }

  // Image upload
  $("#fileInput").addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) await addImageLayerFromFile(file);
    e.target.value = "";
  });

  initDefault();
  render();
})();
</script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Rubik’s Cube Solver — Three.js + Kociemba</title>

<style>
:root{
  --bg:#fff7e6;
  --card:#ffffff;
  --ink:#1f2937;
  --brand:#d97706;
  --brand2:#f59e0b;
  --border:#eadcc5;
  --shadow:0 18px 40px rgba(0,0,0,.15);
}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:var(--bg);
  color:var(--ink);
}
header{
  padding:12px 16px;
  background:#fff;
  border-bottom:1px solid var(--border);
  box-shadow:var(--shadow);
}
h1{margin:0;font-size:18px;color:var(--brand)}
.controls{
  display:flex;
  gap:10px;
  padding:10px;
}
button{
  border:1px solid var(--border);
  background:#fff;
  padding:8px 12px;
  border-radius:10px;
  font-weight:700;
  cursor:pointer;
}
button.primary{
  background:#ffe5b4;
  border-color:var(--brand);
}
#moves{
  padding:10px;
  font-family:monospace;
  background:#0b1220;
  color:#e5e7eb;
  margin:10px;
  border-radius:10px;
  min-height:70px;
}
#stage{
  width:100%;
  height:520px;
}
</style>

<!-- cube.js solver -->
<script src="https://ldez.github.io/cubejs/lib/cube.js"></script>
<script src="https://ldez.github.io/cubejs/lib/async.js"></script>
</head>

<body>
<header>
  <h1>3D Rubik’s Cube Solver (Three.js + Kociemba)</h1>
</header>

<div class="controls">
  <button class="primary" id="scramble">Scramble</button>
  <button class="primary" id="solve">Solve</button>
  <button id="step">Step</button>
  <button id="play">Play</button>
  <button id="reset">Reset</button>
</div>

<div id="moves">Moves will appear here</div>
<div id="stage"></div>

<script type="module">
/* =========================
   THREE.JS IMPORT (FIXED)
========================= */
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* =========================
   BASIC SETUP
========================= */
const stage = document.getElementById("stage");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xfff7e6);

const camera = new THREE.PerspectiveCamera(45, stage.clientWidth/stage.clientHeight, 0.1, 100);
camera.position.set(7,6,8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(stage.clientWidth, stage.clientHeight);
stage.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* =========================
   LIGHTS
========================= */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const d = new THREE.DirectionalLight(0xffffff,0.9);
d.position.set(6,8,6);
scene.add(d);

/* =========================
   RUBIK CUBE VISUAL
========================= */
const cubeGroup = new THREE.Group();
scene.add(cubeGroup);

const SIZE=1, GAP=0.06, STEP=SIZE+GAP;

const COLORS={
  U:0xffffff, D:0xffd400,
  F:0x00a651, B:0x0047ab,
  R:0xb71234, L:0xff6a00,
  K:0x111111
};

const cubies=[];

function cubie(x,y,z){
  const g=new THREE.BoxGeometry(SIZE,SIZE,SIZE);
  const m=new THREE.MeshStandardMaterial({color:COLORS.K});
  const c=new THREE.Mesh(g,m);
  c.position.set(x*STEP,y*STEP,z*STEP);
  c.userData={x,y,z};

  const p=new THREE.PlaneGeometry(0.9,0.9);
  const o=SIZE/2+0.01;
  const s=(col,pos,rot)=>{
    const f=new THREE.Mesh(p,new THREE.MeshStandardMaterial({color:col}));
    f.position.copy(pos);
    f.rotation.set(rot.x,rot.y,rot.z);
    c.add(f);
  };
  if(y==1)s(COLORS.U,new THREE.Vector3(0,o,0),new THREE.Euler(-Math.PI/2,0,0));
  if(y==-1)s(COLORS.D,new THREE.Vector3(0,-o,0),new THREE.Euler(Math.PI/2,0,0));
  if(z==1)s(COLORS.F,new THREE.Vector3(0,0,o),new THREE.Euler(0,0,0));
  if(z==-1)s(COLORS.B,new THREE.Vector3(0,0,-o),new THREE.Euler(0,Math.PI,0));
  if(x==1)s(COLORS.R,new THREE.Vector3(o,0,0),new THREE.Euler(0,-Math.PI/2,0));
  if(x==-1)s(COLORS.L,new THREE.Vector3(-o,0,0),new THREE.Euler(0,Math.PI/2,0));

  return c;
}

function buildCube(){
  cubeGroup.clear();
  cubies.length=0;
  for(let x=-1;x<=1;x++)
    for(let y=-1;y<=1;y++)
      for(let z=-1;z<=1;z++){
        const c=cubie(x,y,z);
        cubies.push(c);
        cubeGroup.add(c);
      }
}
buildCube();

/* =========================
   SOLVER MODEL
========================= */
let model=new Cube();
let queue=[];
let playing=false;

Cube.asyncInit("https://ldez.github.io/cubejs/lib/worker.js");

/* =========================
   MOVE ENGINE
========================= */
function axis(face){
  return {
    R:{a:new THREE.Vector3(1,0,0),k:"x",v:1,s:-1},
    L:{a:new THREE.Vector3(1,0,0),k:"x",v:-1,s:1},
    U:{a:new THREE.Vector3(0,1,0),k:"y",v:1,s:1},
    D:{a:new THREE.Vector3(0,1,0),k:"y",v:-1,s:-1},
    F:{a:new THREE.Vector3(0,0,1),k:"z",v:1,s:-1},
    B:{a:new THREE.Vector3(0,0,1),k:"z",v:-1,s:1}
  }[face];
}

async function turn(move){
  const f=move[0],info=axis(f);
  let t=1,d=1;
  if(move.endsWith("2"))t=2;
  if(move.endsWith("'"))d=-1;

  const angle=Math.PI/2*t*d*info.s;
  const layer=cubies.filter(c=>c.userData[info.k]==info.v);

  const g=new THREE.Group();
  cubeGroup.add(g);
  layer.forEach(c=>g.attach(c));

  let s=performance.now();
  await new Promise(r=>{
    function anim(n){
      let p=Math.min(1,(n-s)/300);
      g.setRotationFromAxisAngle(info.a,angle*p);
      if(p<1)requestAnimationFrame(anim);
      else r();
    }
    requestAnimationFrame(anim);
  });

  g.updateMatrixWorld();
  layer.forEach(c=>{
    c.applyMatrix4(g.matrix);
    cubeGroup.attach(c);
    c.userData={
      x:Math.round(c.position.x/STEP),
      y:Math.round(c.position.y/STEP),
      z:Math.round(c.position.z/STEP)
    };
  });
  cubeGroup.remove(g);
}

async function step(){
  if(!queue.length)return;
  const m=queue.shift();
  model.move(m);
  await turn(m);
  showMoves();
}

async function play(){
  playing=true;
  while(queue.length && playing) await step();
  playing=false;
}

/* =========================
   UI
========================= */
const movesBox=document.getElementById("moves");
function showMoves(){
  movesBox.textContent=queue.join(" ");
}

document.getElementById("scramble").onclick=()=>{
  queue=[];
  model=new Cube();
  buildCube();
  const faces=["R","L","U","D","F","B"];
  const suf=["","'","2"];
  for(let i=0;i<20;i++){
    const m=faces[Math.random()*6|0]+suf[Math.random()*3|0];
    queue.push(m);
    model.move(m);
  }
  showMoves();
};

document.getElementById("solve").onclick=()=>{
  Cube.asyncSolve(new Cube(model),(alg)=>{
    queue=alg.trim().split(/\s+/);
    showMoves();
  });
};

document.getElementById("step").onclick=step;
document.getElementById("play").onclick=play;
document.getElementById("reset").onclick=()=>{
  queue=[];
  model=new Cube();
  buildCube();
  showMoves();
};

/* =========================
   RENDER LOOP
========================= */
function animate(){
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

window.onresize=()=>{
  camera.aspect=stage.clientWidth/stage.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(stage.clientWidth,stage.clientHeight);
};
</script>
</body>
</html>

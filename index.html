<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Learn Chess — Interactive Basics + Play vs Computer</title>
  <meta name="description" content="Learn chess basics with an interactive board, lessons, quizzes, and play vs computer. Works offline." />
  <style>
    :root{
      --bg:#fff7e6; --card:#fff; --ink:#1f2937; --muted:#6b7280;
      --brand:#d97706; --brand2:#f59e0b; --border:#eadcc5;
      --shadow:0 18px 40px rgba(31,41,55,.14);
      --ok:#166534; --danger:#b91c1c;
      --sqLight:#f3d7ad; --sqDark:#c77d2a;
      --hl2:#34d399; --cap:#f87171;
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 800px at 15% 0%, #fff 0%, var(--bg) 55%, #ffecc7 100%);
      color:var(--ink);
    }
    .wrap{max-width:1100px;margin:18px auto;padding:14px}
    .topbar{
      display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;
      background:rgba(255,255,255,.75);backdrop-filter: blur(10px);
      border:1px solid var(--border); border-radius:999px; padding:10px 12px;
      box-shadow:0 10px 25px rgba(31,41,55,.10);
      position:sticky; top:10px; z-index:10;
    }
    .brand{display:flex;align-items:center;gap:10px}
    .logo{
      width:38px;height:38px;border-radius:12px;
      background: conic-gradient(from 180deg, var(--brand2), var(--brand), #ffcf7a, var(--brand2));
      box-shadow: 0 10px 20px rgba(217,119,6,.25);
      position:relative;
    }
    .logo:after{
      content:"♞"; position:absolute; inset:0; display:grid; place-items:center;
      font-size:22px; color:#1f2937; filter: drop-shadow(0 2px 0 rgba(255,255,255,.6));
    }
    h1{margin:0;font-size:18px}
    .sub{color:var(--muted);font-size:12px;margin-top:2px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{
      border:1px solid var(--border); background:#fff; color:var(--ink);
      padding:9px 11px;border-radius:999px; cursor:pointer;
      box-shadow: 0 10px 18px rgba(31,41,55,.08);
      font-weight:650; font-size:13px;
    }
    .btn.primary{
      border-color: rgba(217,119,6,.35);
      background: linear-gradient(180deg, #fff, #fff6e7);
    }
    .btn:active{transform:translateY(1px)}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid var(--border); background:rgba(255,255,255,.7);
      border-radius:999px; padding:8px 10px;
      font-size:13px;
    }
    select, input[type="checkbox"]{cursor:pointer}
    .grid{
      display:grid; gap:14px;
      grid-template-columns: 420px 1fr;
      margin-top:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    .card{
      background:rgba(255,255,255,.85);
      border:1px solid var(--border);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .card .bd{padding:14px}
    .kpi{display:flex;gap:8px;flex-wrap:wrap}
    .tag{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid var(--border); background:#fff;
      color:var(--muted);
    }

    .boardWrap{padding:14px}
    .board{
      width:100%;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 18px 34px rgba(31,41,55,.12);
      user-select:none;
    }
    .sq{
      display:grid; place-items:center;
      font-size: 34px;
      position:relative;
      cursor:pointer;
      transition: transform .05s ease;
    }
    .sq:active{transform:scale(.99)}
    .sq.light{background: linear-gradient(180deg, #ffe7c3, var(--sqLight))}
    .sq.dark{background: linear-gradient(180deg, #d78c2f, var(--sqDark))}
    .sq .coord{
      position:absolute; left:6px; bottom:4px;
      font-size:10px; color: rgba(0,0,0,.45);
      font-weight:700;
    }
    .sq.dark .coord{color: rgba(255,255,255,.55)}
    .sq.selected{outline: 3px solid rgba(96,165,250,.9); outline-offset:-3px}
    .sq.hl::after{
      content:"";
      width: 16px; height:16px; border-radius:999px;
      background: rgba(52,211,153,.75);
      box-shadow: 0 0 0 3px rgba(255,255,255,.35);
      position:absolute;
    }
    .sq.cap::after{
      content:"";
      width: 16px; height:16px; border-radius:999px;
      background: rgba(248,113,113,.80);
      box-shadow: 0 0 0 3px rgba(255,255,255,.35);
      position:absolute;
    }
    .sq.lastFrom{box-shadow: inset 0 0 0 3px rgba(96,165,250,.55)}
    .sq.lastTo{box-shadow: inset 0 0 0 3px rgba(245,158,11,.65)}

    .panel{display:grid; gap:14px}
    .two{display:grid; gap:14px; grid-template-columns: 1.1fr .9fr}
    @media (max-width: 980px){
      .two{grid-template-columns:1fr}
    }
    .hint{
      border:1px dashed rgba(217,119,6,.45);
      background: #fffaf0;
      padding:10px 12px;
      border-radius: 14px;
      color:#7c2d12;
      font-size:13px;
    }
    .muted{color:var(--muted)}
    .list{margin:8px 0 0 18px;color:var(--ink)}
    .list li{margin:6px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .hr{height:1px;background:var(--border);margin:12px 0}
    .small{font-size:12px}
    .toast{
      position: fixed; right: 14px; bottom: 14px;
      background: rgba(255,255,255,.92);
      border:1px solid var(--border);
      border-radius: 14px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      max-width: 380px;
      display:none;
      z-index: 20;
    }
    .toast.show{display:block}
    .toast strong{display:block;margin-bottom:2px}
    .kbd{
      font: 600 11px/1 ui-monospace,monospace;
      background:#fff; border:1px solid var(--border); border-bottom-width:3px;
      padding:2px 6px;border-radius:8px; color:#111827;
    }
    .quizQ{font-weight:800;margin:0 0 8px}
    .opt{display:flex;gap:8px;align-items:flex-start;margin:8px 0}
    .opt input{margin-top:3px}
    .score{
      font-weight:900;
      padding:6px 10px;border-radius:999px;
      border:1px solid var(--border); background:#fff;
    }
    .good{color:var(--ok)}
    .bad{color:var(--danger)}
    .footer{margin:14px 0 0;text-align:center;color:var(--muted);font-size:12px}
    .lock{opacity:.65; pointer-events:none; filter:grayscale(.2)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Learn Chess — Interactive Basics</h1>
          <div class="sub">Learn Moves • Practice • Quiz • <b>Play vs Computer</b> • Offline</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn primary" id="btnReset">Reset Position</button>
        <button class="btn" id="btnFlip">Flip Board</button>
        <button class="btn" id="btnHint">Show Hint</button>

        <span class="pill">
          Mode:
          <select id="mode">
            <option value="learn" selected>Learn Moves</option>
            <option value="practice">Practice Tasks</option>
            <option value="quiz">Quick Quiz</option>
            <option value="cpu">Play vs Computer</option>
          </select>
        </span>

        <span class="pill">
          CPU:
          <select id="cpuLevel">
            <option value="easy" selected>Easy</option>
            <option value="medium">Medium</option>
          </select>
        </span>

        <span class="pill">
          <label class="row" style="gap:8px;margin:0">
            <input type="checkbox" id="showCoords" checked />
            <span>Coords</span>
          </label>
        </span>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: BOARD -->
      <div class="card">
        <div class="hd">
          <div>
            <strong>Board</strong>
            <div class="muted small">Tap: select → tap: move</div>
          </div>
          <div class="kpi">
            <span class="tag">Turn: <strong id="turnTag">White</strong></span>
            <span class="tag">Selected: <strong id="selTag">—</strong></span>
            <span class="tag">Game: <strong id="gameTag">Free</strong></span>
          </div>
        </div>
        <div class="boardWrap">
          <div class="board" id="board" aria-label="Chess board"></div>
          <div class="hr"></div>
          <div class="hint" id="status">
            Tip: Start with the <b>Knight ♞</b>. It moves in an “L”: 2 squares in one direction + 1 perpendicular.
          </div>
          <div class="footer">
            Shortcuts: <span class="kbd">R</span> reset • <span class="kbd">F</span> flip • <span class="kbd">H</span> hint
          </div>
        </div>
      </div>

      <!-- RIGHT: PANELS -->
      <div class="panel">
        <div class="card">
          <div class="hd">
            <strong>Lessons</strong>
            <span class="tag">Basics</span>
          </div>
          <div class="bd">
            <div class="two">
              <div>
                <p style="margin:0 0 8px">
                  Chess goal: <b>Checkmate</b> the opponent’s king — attack the king so it has no legal escape.
                </p>
                <ul class="list">
                  <li><b>King ♔</b>: 1 square any direction (we don’t enforce “check” yet).</li>
                  <li><b>Queen ♕</b>: rook + bishop combined (any distance).</li>
                  <li><b>Rook ♖</b>: straight lines (any distance).</li>
                  <li><b>Bishop ♗</b>: diagonals (any distance).</li>
                  <li><b>Knight ♘</b>: “L” shape, can jump over pieces.</li>
                  <li><b>Pawn ♙</b>: forward 1 (or 2 from start), captures diagonally.</li>
                </ul>
                <div class="hr"></div>
                <div class="small muted">
                  Note: This trainer does not validate check/castling/en-passant/promotion yet (movement rules only).
                </div>
              </div>
              <div>
                <div class="hint">
                  <b>Play vs Computer</b><br/>
                  You are <b>White</b>. Make a move, then the computer (Black) replies automatically.
                  Computer chooses captures and good trades using a simple evaluation.
                </div>
                <div class="hr"></div>
                <div class="row">
                  <button class="btn" id="btnLoadKnight">Focus: Knight</button>
                  <button class="btn" id="btnLoadMate">Mini: Mate Net</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card" id="practiceCard" style="display:none">
          <div class="hd">
            <strong>Practice Tasks</strong>
            <span class="tag">Do 5 minutes</span>
          </div>
          <div class="bd">
            <p class="quizQ" id="taskTitle">Task</p>
            <div class="muted" id="taskText"></div>
            <div class="hr"></div>
            <div class="row">
              <button class="btn primary" id="btnNextTask">Next Task</button>
              <button class="btn" id="btnShowAnswer">Show Answer</button>
              <span class="score" id="taskCounter">1 / 8</span>
            </div>
            <div class="hr"></div>
            <div class="small muted" id="answerBox" style="display:none"></div>
          </div>
        </div>

        <div class="card" id="quizCard" style="display:none">
          <div class="hd">
            <strong>Quick Quiz</strong>
            <span class="tag">5 Qs</span>
          </div>
          <div class="bd">
            <p class="quizQ" id="quizQ"></p>
            <div id="quizOpts"></div>
            <div class="hr"></div>
            <div class="row">
              <button class="btn primary" id="btnCheck">Check</button>
              <button class="btn" id="btnNextQ">Next</button>
              <span class="score">Score: <span id="quizScore">0</span>/5</span>
            </div>
            <div class="hr"></div>
            <div class="small muted" id="quizExplain"></div>
          </div>
        </div>

      </div>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>
  </div>

  <script>
    // ---------- Chess Learn Page + CPU (Simple Move Rules + Simple AI) ----------
    // Still NOT a full chess engine: no check/castle/en-passant/promotion validation.
    // CPU picks moves using material + small lookahead.

    const PIECES = {
      "K":"♔","Q":"♕","R":"♖","B":"♗","N":"♘","P":"♙",
      "k":"♚","q":"♛","r":"♜","b":"♝","n":"♞","p":"♟"
    };

    const state = {
      flip: false,
      showCoords: true,
      turn: "w",            // w or b
      board: [],            // 8x8
      selected: null,       // {r,c}
      moves: [],            // list of {r,c,type:"move"|"cap"}
      lastMove: null,       // {from:{r,c},to:{r,c}}
      mode: "learn",        // learn | practice | quiz | cpu
      cpuLevel: "easy",     // easy | medium
      cpuThinking: false,
      gameOver: false
    };

    const el = (id)=>document.getElementById(id);
    const boardEl = el("board");
    const statusEl = el("status");
    const turnTag = el("turnTag");
    const selTag = el("selTag");
    const gameTag = el("gameTag");
    const toastEl = el("toast");

    const modeSel = el("mode");
    const showCoordsCb = el("showCoords");
    const cpuLevelSel = el("cpuLevel");

    const practiceCard = el("practiceCard");
    const quizCard = el("quizCard");

    const START = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"],
    ];

    function cloneBoard(b){ return b.map(row=>row.slice()); }
    function reset(){
      state.board = cloneBoard(START);
      state.selected = null;
      state.moves = [];
      state.turn = "w";
      state.lastMove = null;
      state.cpuThinking = false;
      state.gameOver = false;
      render();
      setStatus('Tip: Click a piece to see moves. Try the Knight ♞ first!');
      updateGameTag();
    }

    function setStatus(html){ statusEl.innerHTML = html; }
    function toast(title, msg){
      toastEl.innerHTML = `<strong>${title}</strong><div class="small muted">${msg}</div>`;
      toastEl.classList.add("show");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 2200);
    }

    function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
    function isWhite(ch){ return ch && ch.toUpperCase()===ch; }
    function isBlack(ch){ return ch && ch.toLowerCase()===ch; }

    function algebra(r,c){
      const file = "abcdefgh"[c];
      const rank = (8 - r);
      return file + rank;
    }

    function viewToModel(vr,vc){
      if(!state.flip) return {r:vr,c:vc};
      return {r:7-vr,c:7-vc};
    }
    function pieceAt(board,r,c){ return (board ? board[r][c] : state.board[r][c]) || ""; }

    function getMovesFor(board,r,c){
      const p = pieceAt(board,r,c);
      if(!p) return [];
      const side = isWhite(p) ? "w" : "b";
      const enemy = side==="w" ? "b" : "w";
      const moves = [];
      const push = (rr,cc,type)=>moves.push({r:rr,c:cc,type});

      const addRay = (dr,dc)=>{
        let rr=r+dr, cc=c+dc;
        while(inBounds(rr,cc)){
          const t = pieceAt(board,rr,cc);
          if(!t){ push(rr,cc,"move"); }
          else{
            const tSide = isWhite(t) ? "w" : "b";
            if(tSide===enemy) push(rr,cc,"cap");
            break;
          }
          rr+=dr; cc+=dc;
        }
      };

      const up = side==="w" ? -1 : 1;

      switch(p.toLowerCase()){
        case "p":{
          const fr = r + up;
          if(inBounds(fr,c) && !pieceAt(board,fr,c)){
            push(fr,c,"move");
            const startRow = side==="w" ? 6 : 1;
            const fr2 = r + up*2;
            if(r===startRow && inBounds(fr2,c) && !pieceAt(board,fr2,c)) push(fr2,c,"move");
          }
          for(const dc of [-1,1]){
            const cr = r + up, cc = c + dc;
            if(inBounds(cr,cc)){
              const t = pieceAt(board,cr,cc);
              if(t){
                const tSide = isWhite(t) ? "w" : "b";
                if(tSide===enemy) push(cr,cc,"cap");
              }
            }
          }
          break;
        }
        case "n":{
          const steps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          for(const [dr,dc] of steps){
            const rr=r+dr, cc=c+dc;
            if(!inBounds(rr,cc)) continue;
            const t = pieceAt(board,rr,cc);
            if(!t) push(rr,cc,"move");
            else{
              const tSide = isWhite(t) ? "w" : "b";
              if(tSide===enemy) push(rr,cc,"cap");
            }
          }
          break;
        }
        case "b": addRay(-1,-1); addRay(-1,1); addRay(1,-1); addRay(1,1); break;
        case "r": addRay(-1,0); addRay(1,0); addRay(0,-1); addRay(0,1); break;
        case "q":
          addRay(-1,0); addRay(1,0); addRay(0,-1); addRay(0,1);
          addRay(-1,-1); addRay(-1,1); addRay(1,-1); addRay(1,1);
          break;
        case "k":{
          for(let dr=-1;dr<=1;dr++){
            for(let dc=-1;dc<=1;dc++){
              if(dr===0 && dc===0) continue;
              const rr=r+dr, cc=c+dc;
              if(!inBounds(rr,cc)) continue;
              const t = pieceAt(board,rr,cc);
              if(!t) push(rr,cc,"move");
              else{
                const tSide = isWhite(t) ? "w" : "b";
                if(tSide===enemy) push(rr,cc,"cap");
              }
            }
          }
          break;
        }
      }
      return moves;
    }

    function clearSelection(){
      state.selected = null;
      state.moves = [];
      selTag.textContent = "—";
    }

    function updateTags(){
      turnTag.textContent = state.turn==="w" ? "White" : "Black";
      updateGameTag();
    }
    function updateGameTag(){
      if(state.mode==="cpu") gameTag.textContent = state.cpuThinking ? "CPU thinking…" : "Vs CPU";
      else gameTag.textContent = "Free";
    }

    function selectSquare(r,c){
      const p = pieceAt(null,r,c);
      if(!p){ clearSelection(); render(); return; }

      const side = isWhite(p) ? "w" : "b";

      // In CPU mode, player is White only.
      if(state.mode==="cpu" && side!=="w"){
        toast("Your pieces", "You play White. Select a White piece.");
        return;
      }

      if(side !== state.turn){
        toast("Not your turn", `It's ${state.turn==="w"?"White":"Black"} to move.`);
        return;
      }

      state.selected = {r,c};
      state.moves = getMovesFor(state.board,r,c);
      selTag.textContent = `${PIECES[p]} ${algebra(r,c)}`;
      render();
    }

    function applyMove(board, from, to){
      const p = pieceAt(board,from.r,from.c);
      const target = pieceAt(board,to.r,to.c);
      board[to.r][to.c] = p;
      board[from.r][from.c] = "";
      return {p, target};
    }

    function hasKing(board, side){
      const k = side==="w" ? "K" : "k";
      for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(board[r][c]===k) return true;
      return false;
    }

    function tryMove(toR,toC){
      if(!state.selected) return false;
      const from = state.selected;
      const legal = state.moves.find(m=>m.r===toR && m.c===toC);
      if(!legal) return false;

      const p = pieceAt(null,from.r,from.c);
      const target = pieceAt(null,toR,toC);

      applyMove(state.board, from, {r:toR,c:toC});

      state.lastMove = {from:{...from}, to:{r:toR,c:toC}};
      clearSelection();

      // End if king captured (since we're not checking checkmates)
      if(target && (target==="k" || target==="K")){
        state.gameOver = true;
        toast("Game Over", `${PIECES[p]} captured the king on ${algebra(toR,toC)} (trainer mode).`);
        setStatus("Game Over (trainer): A king was captured. Reset to play again.");
      }

      // toggle turn unless game over
      if(!state.gameOver){
        state.turn = (state.turn==="w") ? "b" : "w";
      }
      updateTags();

      if(target){
        toast("Capture!", `${PIECES[p]} captured ${PIECES[target]} on ${algebra(toR,toC)}.`);
      }else{
        toast("Moved", `${PIECES[p]} to ${algebra(toR,toC)}.`);
      }

      if(!state.gameOver){
        if(state.mode==="practice") setStatus(`Practice: Complete the task shown on the right.`);
        else if(state.mode==="quiz") setStatus(`Quiz: Answer on the right. Use the board to visualize.`);
        else if(state.mode==="cpu") setStatus(`Vs CPU: Your move (White). After you move, Black replies automatically.`);
        else setStatus(`Tip: Click a piece to see its moves. Green = move, Red = capture.`);
      }

      render();

      // CPU reply if needed
      if(state.mode==="cpu" && !state.gameOver && state.turn==="b"){
        cpuReply();
      }
      return true;
    }

    function onSquareClick(vr,vc){
      if(state.gameOver) return;

      // Block clicks while CPU is thinking
      if(state.mode==="cpu" && state.cpuThinking) return;

      const {r,c} = viewToModel(vr,vc);

      if(state.selected){
        if(tryMove(r,c)) return;

        const p = pieceAt(null,r,c);
        if(p){
          const side = isWhite(p) ? "w" : "b";
          if(side===state.turn){
            selectSquare(r,c);
            return;
          }
        }
        clearSelection();
        render();
        return;
      }
      selectSquare(r,c);
    }

    function render(){
      boardEl.innerHTML = "";
      updateTags();

      for(let vr=0; vr<8; vr++){
        for(let vc=0; vc<8; vc++){
          const {r,c} = viewToModel(vr,vc);
          const sq = document.createElement("div");
          const isLight = ((r+c)%2===0);
          sq.className = "sq " + (isLight ? "light":"dark");
          sq.dataset.vr = vr; sq.dataset.vc = vc;

          const p = pieceAt(null,r,c);
          sq.textContent = p ? PIECES[p] : "";

          if(state.selected && state.selected.r===r && state.selected.c===c) sq.classList.add("selected");

          if(state.lastMove){
            if(state.lastMove.from.r===r && state.lastMove.from.c===c) sq.classList.add("lastFrom");
            if(state.lastMove.to.r===r && state.lastMove.to.c===c) sq.classList.add("lastTo");
          }

          if(state.moves && state.moves.length){
            const m = state.moves.find(x=>x.r===r && x.c===c);
            if(m) sq.classList.add(m.type==="cap" ? "cap" : "hl");
          }

          if(state.showCoords){
            const coord = document.createElement("div");
            coord.className = "coord";
            coord.textContent = algebra(r,c);
            sq.appendChild(coord);
          }

          sq.addEventListener("click", ()=>onSquareClick(vr,vc));
          boardEl.appendChild(sq);
        }
      }

      // add "lock" feel while CPU thinking
      if(state.mode==="cpu" && state.cpuThinking){
        boardEl.parentElement.classList.add("lock");
      }else{
        boardEl.parentElement.classList.remove("lock");
      }
    }

    // ---------- CPU (Black) ----------
    const VAL = { p:100, n:320, b:330, r:500, q:900, k:20000 };
    function valueOfPiece(ch){
      if(!ch) return 0;
      const v = VAL[ch.toLowerCase()] || 0;
      return isWhite(ch) ? v : -v;
    }

    function evalBoard(board){
      // material + small center bonus
      let s = 0;
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const p = board[r][c];
          if(!p) continue;
          s += valueOfPiece(p);
          // center bonus
          const center = (r>=2 && r<=5 && c>=2 && c<=5) ? 6 : 0;
          s += isWhite(p) ? center : -center;
        }
      }
      return s; // positive => better for White
    }

    function listAllMoves(board, side){
      const out = [];
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const p = pieceAt(board,r,c);
          if(!p) continue;
          if(side==="w" && !isWhite(p)) continue;
          if(side==="b" && !isBlack(p)) continue;
          const ms = getMovesFor(board,r,c);
          for(const m of ms){
            out.push({from:{r,c}, to:{r:m.r,c:m.c}, type:m.type, piece:p});
          }
        }
      }
      return out;
    }

    function pickCpuMove(board){
      // CPU is Black: tries to minimize eval (reduce White advantage).
      const moves = listAllMoves(board, "b");
      if(moves.length===0) return null;

      const depth = (state.cpuLevel==="medium") ? 2 : 1; // tiny lookahead
      let best = null;
      let bestScore = Infinity;

      // cheap randomness among near-equals (makes it feel less robotic)
      const jitter = (state.cpuLevel==="easy") ? 10 : 4;

      for(const mv of moves){
        const b1 = cloneBoard(board);
        applyMove(b1, mv.from, mv.to);

        // if captured king, do it
        const captured = pieceAt(b1, mv.to.r, mv.to.c);
        // captured value already in board, but king capture ends quickly in our trainer rules.
        if(!hasKing(b1,"w")) return mv;

        let score;
        if(depth===1){
          score = evalBoard(b1);
        }else{
          // White best reply (maximize eval)
          const replies = listAllMoves(b1, "w");
          if(replies.length===0){
            score = evalBoard(b1);
          }else{
            let bestWhite = -Infinity;
            for(const rply of replies){
              const b2 = cloneBoard(b1);
              applyMove(b2, rply.from, rply.to);
              const s2 = evalBoard(b2);
              if(s2 > bestWhite) bestWhite = s2;
            }
            score = bestWhite;
          }
        }

        // CPU wants minimal score
        const noisy = score + (Math.random()*2 - 1) * jitter;

        // prefer captures a bit on easy (fun), but still eval-based
        const capBonus = (mv.type==="cap") ? -12 : 0;
        const finalScore = noisy + capBonus;

        if(finalScore < bestScore){
          bestScore = finalScore;
          best = mv;
        }
      }
      return best;
    }

    function cpuReply(){
      state.cpuThinking = true;
      updateGameTag();
      setStatus("Vs CPU: Black is thinking…");
      render();

      // quick delay so it feels natural
      setTimeout(()=>{
        const mv = pickCpuMove(state.board);
        state.cpuThinking = false;
        updateGameTag();

        if(!mv){
          toast("CPU", "No moves available.");
          state.gameOver = true;
          setStatus("Game Over: CPU has no moves (trainer). Reset to play again.");
          render();
          return;
        }

        const target = pieceAt(state.board, mv.to.r, mv.to.c);
        applyMove(state.board, mv.from, mv.to);
        state.lastMove = {from:{...mv.from}, to:{...mv.to}};

        clearSelection();

        if(target && (target==="K" || target==="k")){
          state.gameOver = true;
          toast("Game Over", `CPU captured the king on ${algebra(mv.to.r,mv.to.c)} (trainer mode).`);
          setStatus("Game Over (trainer): A king was captured. Reset to play again.");
        }else{
          // switch back to White
          state.turn = "w";
          toast("CPU moved", `${PIECES[mv.piece]} ${algebra(mv.from.r,mv.from.c)} → ${algebra(mv.to.r,mv.to.c)}.`);
          setStatus("Vs CPU: Your move (White).");
        }

        updateTags();
        render();
      }, 380);
    }

    // ---------- Modes: Practice / Quiz ----------
    const tasks = [
      { title:"Knight Tour (Mini)", text:"Select a Knight and make 3 legal knight moves in a row.", answer:"Knights move in an L and can jump over pieces." },
      { title:"Bishop Diagonals", text:"Select a Bishop. Move it along a diagonal to a new square.", answer:"Bishops move diagonally and stay on the same color." },
      { title:"Rook Files & Ranks", text:"Select a Rook. Move it in a straight line.", answer:"Rooks move up/down/left/right any distance until blocked." },
      { title:"Queen Power", text:"Select a Queen and observe rook + bishop moves.", answer:"Queen combines rook + bishop movement." },
      { title:"Pawn Rules", text:"Move a pawn forward 1 (or 2 from start). Try a diagonal capture if possible.", answer:"Pawns capture diagonally, not forward." },
      { title:"Create an Attack", text:"Capture one opponent pawn with any piece (red dots show captures).", answer:"Use red dots (captures) to take an enemy pawn." },
      { title:"Open a Line", text:"Move a pawn to open a bishop or queen line.", answer:"Central pawn moves often open diagonals." },
      { title:"Mini Check (Concept)", text:"Put a piece on a square that attacks the enemy king (we don't enforce check).", answer:"Use rook/bishop/queen lines to attack the king." },
    ];
    let taskIndex = 0;
    function showTask(i){
      taskIndex = i % tasks.length;
      el("taskTitle").textContent = tasks[taskIndex].title;
      el("taskText").textContent = tasks[taskIndex].text;
      el("taskCounter").textContent = `${taskIndex+1} / ${tasks.length}`;
      el("answerBox").style.display = "none";
      el("answerBox").textContent = tasks[taskIndex].answer;
    }

    const quiz = [
      { q:"Which piece can jump over other pieces?", opts:["Bishop","Knight","Rook","Queen"], a:1, e:"Knights jump and move in an L-shape." },
      { q:"A bishop always stays on the same color squares. True or false?", opts:["True","False"], a:0, e:"Diagonal movement keeps it on the same color." },
      { q:"How does a pawn capture?", opts:["Straight forward","Diagonally forward","Like a knight","Backward diagonally"], a:1, e:"Pawns capture one step diagonally forward." },
      { q:"The queen moves like…", opts:["Only diagonals","Only straight lines","Rook + Bishop combined","One square only"], a:2, e:"Queen = rook + bishop movement." },
      { q:"Goal of chess is to…", opts:["Capture all pieces","Checkmate the king","Promote a pawn","Win material"], a:1, e:"You win by checkmating the king." },
    ];
    let qIndex = 0, qScore = 0, qChecked = false;

    function renderQuiz(){
      qChecked = false;
      el("quizExplain").textContent = "";
      const item = quiz[qIndex];
      el("quizQ").textContent = item.q;
      const box = el("quizOpts");
      box.innerHTML = "";
      item.opts.forEach((t,idx)=>{
        const row = document.createElement("label");
        row.className = "opt";
        row.innerHTML = `<input type="radio" name="q" value="${idx}"/> <span>${t}</span>`;
        box.appendChild(row);
      });
      el("quizScore").textContent = qScore;
    }
    function getSelectedQuizOpt(){
      const checked = document.querySelector('input[name="q"]:checked');
      return checked ? parseInt(checked.value,10) : -1;
    }
    function checkQuiz(){
      if(qChecked) return;
      const pick = getSelectedQuizOpt();
      if(pick<0){ toast("Choose an option","Select one answer first."); return; }
      qChecked = true;
      const item = quiz[qIndex];
      if(pick === item.a){ qScore++; el("quizExplain").innerHTML = `<span class="good"><b>Correct.</b></span> ${item.e}`; }
      else el("quizExplain").innerHTML = `<span class="bad"><b>Not quite.</b></span> ${item.e}`;
      el("quizScore").textContent = qScore;
    }
    function nextQuiz(){
      qIndex = (qIndex + 1) % quiz.length;
      renderQuiz();
      setStatus("Quiz: Answer on the right. Use the board to visualize.");
    }

    // ---------- Lesson quick loaders ----------
    function loadKnightFocus(){
      state.board = Array.from({length:8}, ()=>Array(8).fill(""));
      state.board[7][1] = "N"; // b1
      state.board[6][3] = "P"; // d2
      state.board[5][2] = "p"; // c3
      state.board[4][4] = "p"; // e4
      state.turn = "w";
      state.lastMove = null;
      state.gameOver = false;
      clearSelection();
      render();
      setStatus("Knight Focus: Click the knight ♘ and see its moves. Red dots are captures.");
      toast("Loaded","Knight focus position loaded.");
    }
    function loadMateNet(){
      state.board = Array.from({length:8}, ()=>Array(8).fill(""));
      state.board[0][4] = "k"; // e8
      state.board[7][4] = "K"; // e1
      state.board[6][4] = "Q"; // e2
      state.board[6][7] = "R"; // h2
      state.turn = "w";
      state.lastMove = null;
      state.gameOver = false;
      clearSelection();
      render();
      setStatus("Mate Net (Concept): Use queen + rook to restrict the king. Try attacking e8.");
      toast("Loaded","Mate-net mini position loaded.");
    }

    // ---------- Wire UI ----------
    el("btnReset").addEventListener("click", reset);
    el("btnFlip").addEventListener("click", ()=>{ state.flip=!state.flip; render(); toast("Board", state.flip ? "Flipped view." : "Normal view."); });
    el("btnHint").addEventListener("click", ()=>{
      const tips = [
        "Control the center early: e4/d4/e5/d5 matter.",
        "Develop knights & bishops before moving queen too much.",
        "Watch red dots: don’t hang pieces.",
        "Knights love safe outposts.",
        "Open lines for bishops/rooks."
      ];
      const t = tips[Math.floor(Math.random()*tips.length)];
      setStatus("Hint: " + t);
      toast("Hint", t);
    });

    el("btnLoadKnight").addEventListener("click", loadKnightFocus);
    el("btnLoadMate").addEventListener("click", loadMateNet);

    showCoordsCb.addEventListener("change", ()=>{ state.showCoords = showCoordsCb.checked; render(); });
    cpuLevelSel.addEventListener("change", ()=>{ state.cpuLevel = cpuLevelSel.value; toast("CPU level", state.cpuLevel==="easy"?"Easy":"Medium"); });

    modeSel.addEventListener("change", ()=>{
      state.mode = modeSel.value;
      practiceCard.style.display = (state.mode==="practice") ? "" : "none";
      quizCard.style.display = (state.mode==="quiz") ? "" : "none";

      state.gameOver = false;
      state.cpuThinking = false;

      if(state.mode==="learn"){
        setStatus("Learn Moves: Click a piece to see legal moves. Green=move, Red=capture.");
      }else if(state.mode==="practice"){
        showTask(taskIndex);
        setStatus("Practice: Complete the task shown on the right. Use Reset if stuck.");
      }else if(state.mode==="quiz"){
        renderQuiz();
        setStatus("Quiz: Answer on the right. Use the board to visualize.");
      }else if(state.mode==="cpu"){
        // reset for fair play and force player as White
        reset();
        state.mode = "cpu";
        setStatus("Vs CPU: You are White. Make a move; Black replies automatically.");
        toast("Vs CPU", "You are White. Good luck!");
      }
      render();
    });

    el("btnNextTask").addEventListener("click", ()=>{ showTask(taskIndex+1); toast("Practice","Next task loaded."); });
    el("btnShowAnswer").addEventListener("click", ()=>{
      const box = el("answerBox");
      box.style.display = (box.style.display==="none") ? "" : "none";
      toast("Answer", box.style.display==="none" ? "Hidden." : "Shown.");
    });

    el("btnCheck").addEventListener("click", checkQuiz);
    el("btnNextQ").addEventListener("click", nextQuiz);

    window.addEventListener("keydown", (e)=>{
      if(e.key.toLowerCase()==="r") reset();
      if(e.key.toLowerCase()==="f") el("btnFlip").click();
      if(e.key.toLowerCase()==="h") el("btnHint").click();
    });

    // init
    reset();
    showTask(0);
    renderQuiz();
  </script>
</body>
</html>